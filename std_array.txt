  /**
   *  @brief A standard container for storing a fixed size sequence of elements.
   *
   *  @ingroup sequences
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and a
   *  <a href="tables.html#67">sequence</a>.
   *
   *  Sets support random access iterators.
   *
   *  @tparam  Tp  Type of element. Required to be a complete type.
   *  @tparam  Nm  Number of elements.

    저장 구조 & 타입 특성
    메모리 레이아웃 = C 배열 그대로: 내부 저장소는 __array_traits<T, N>::_Type _M_elems;이며, 
    N>0이면 사실상 T _M_elems[N];로 정적·연속 저장이다. 힙 할당 없음, 요소는 객체 내에 그대로 들어간다.
    
    N=0 특수화: std::array<T, 0>은 진짜 T[0]를 두지 않고, 인덱싱 시 trap을 터뜨리는 _Type(빈 대체 타입)을 둔다. 
    포인터 변환은 nullptr을 돌려준다(빈 배열의 포인터 의미를 일관되게 유지).

    Aggregate: 사용자 정의 생성자/소멸자 없음 → **집합체(aggregate)**라서 {} 초기화 및 구조적 바인딩과 잘 맞는다. 
    trivial 여부, 복사/이동의 noexcept 여부 등은 전부 요소 타입 T 특성에 의해 결정된다.

    반복자/접근자(모두 포인터 기반)
    iterator = T*, const_iterator = const T*: begin()/end()는 내부 data() 포인터를 그대로 돌려준다. 
    즉 임의 접근 반복자 & 연속 메모리 보장. rbegin()/rend()는 표준 reverse_iterator로 래핑.
    **data()는 _M_elems를 T/const T로 캐스팅해 반환한다. 포인터 산술로 매우 저렴하게 순회 가능.
    **at()**는 경계 체크 후 범위를 넘으면 std::__throw_out_of_range_fmt로 예외를 던진다. 
    반면 operator[]는 범위 체크가 없고(디버그 모드 매크로로만 assert), UB 가능.
    front()/back(): 비어 있으면(특히 N=0) 내부 디버그 매크로가 잡아줄 수 있으나, 표준적으로는 호출이 UB가 될 수 있으므로 주의.

    용량/크기
    size()/max_size()는 항상 N(상수식). empty()는 N==0. 전부 constexpr이므로 컴파일타임 상수 취급 가능 → 템플릿/정적 문맥에서 유용.

    수정 연산
    fill(u): 전체를 std::fill_n(begin(), size(), u)로 채움. O(N). 예외 안전성은 T의 대입 연산 예외 가능성에 따라.
    swap(other)(멤버): std::swap_ranges(begin(), end(), other.begin()). 즉 요소별 스왑이며 O(N). 
    단, T가 nothrow swappable이면 noexcept도 전파된다. (비멤버 swap(array&, array&)도 제약된 오버로드로 멤버 호출.)
    성능 팁: T가 작은 trivially swappable이면 사실상 memcpy급. 무거운 타입이면 N번 스왑 비용을 고려.

    비교 연산
    C++20 삼항 비교(operator<=>): 가능한 경우(요소 타입이 memcmp로 정렬 가능하고, 런타임 상수 평가가 아닐 때) __builtin_memcmp 최적화로 한 방에 비교한다. 
    불가능하면 요소를 순차 비교. 동등성/사전식 비교 모두 지원.
    C++20 미만: operator==는 std::equal, <는 std::lexicographical_compare로 구현. O(N).

    튜플 인터페이스 & 구조적 바인딩
    tuple_size<array<T,N>> = N, tuple_element<i, array<T,N>>::type = T 특수화 제공 → std::get<i>(arr) 가능, 
    C++17 구조적 바인딩도 자연스럽게 동작. 또한 C++17의 tuple_size_v 등 상수도 제공.
    get<i>(array&), get<i>(const array&), get<i>(array&&) 오버로드가 직접 _M_elems[i]를 참조/이동해 돌려준다.

    to_array(배열 → std::array) (C++20)
    to_array(T (&a)[N])/to_array(T (&&a)[N])를 제공. trivially copyable 등 조건을 만족하면 __builtin_memcpy로 한 번에 복사, 
    아니면 인덱스 시퀀스로 요소 단위 복사/이동을 생성한다. is_constant_evaluated() 분기까지 고려되어 constexpr 환경에서도 동작한다.

    클래스 템플릿 인수 추론(CTAD) 가이드
    array(x0, x1, ..., xk) 형태에서 모든 인수 타입이 동일하면 array<T, k+1>로 유추. 
    이로써 std::array a{1,2,3}; 같은 축약 표기가 가능(단, 혼합 타입은 금지).

    예외/Noexcept/Trivial 특성의 전파
    멤버 함수들의 noexcept 여부는 요소 타입 특성을 그대로 반영(예: swap은 T가 nothrow swappable이면 nothrow). 
    동일하게 복사/이동/할당/소멸의 trivial 여부도 T에 의해 결정 → “컨테이너 오버헤드 0” 설계를 지향.
    std::array 자체는 상태가 없고 크기 고정이라 재할당, 용량 개념이 없으며, 대부분의 연산은 포인터 산술/범용 알고리즘 호출에 불과.

    디버그 훅/어설션
    libstdc++는 디버그 빌드에서 __glibcxx_requires_subscript, __glibcxx_requires_nonempty 같은 
    매크로로 진입 전제(인덱스/비어있지 않음)를 검사한다. 
    릴리스 모드에서는 대부분 빠짐.

    성능·올바름 관점 요약
    연속 메모리 + 포인터 반복자: SIMD/캐시 친화적. std::span과도 잘 맞음.
    요소 타입이 곧 성능: T가 trivially copyable이면 to_array, 비교, 
    이동 등이 광범위하게 memcpy/memcmp 최적화 경로를 탄다. 반대로 비싼 T면 swap·비교·fill 모두 O(N)의 무거운 경로.
    사이즈 불변: std::vector와 달리 크기 변경이 없으니 인덱스 기반 접근·반복자 무효화가 없다(단, 
    재배치가 없다는 뜻일 뿐, 여전히 생애주기/수명은 신경 써야 함).
    N=0 취급: 빈 배열도 인터페이스는 유지하되, front()/back()/operator[]는 UB 가능. 
    data()는 nullptr 반환 보장으로 분기 처리 쉬움.
  */
  template<typename _Tp, std::size_t _Nm>
    struct array

/*

    end()는 마지막 원소의 “다음(one-past-the-last)” 를 가리키는 반복자

    기본 전제: std::array는 연속 메모리, 반복자는 사실상 포인터야.

    at(index)

    무엇: 경계 검사 있는 인덱싱, 범위 초과 시 std::out_of_range 예외.

    복잡도: O(1)

    구현 포인트: 내부에서 if (index >= N) throw ...; 후 data()[index] 반환. 디버그/릴리스 상관없이 검사 수행. constexpr(C++23에서 조건부), noexcept(false).

    operator

    무엇: 경계 검사 없는 인덱싱.

    복잡도: O(1)

    구현 포인트: 곧장 *(data() + index) 접근. 범위 밖이면 UB. 매우 얇은 래퍼라 최적화 잘 됨. 대부분 constexpr, noexcept.

    front()

    무엇: 첫 원소 참조.

    복잡도: O(1)

    구현 포인트: *begin(). N==0이면 UB. constexpr, noexcept.

    back()

    무엇: 마지막 원소 참조.

    복잡도: O(1)

    구현 포인트: *(end() - 1). N==0이면 UB. constexpr, noexcept.

    data()

    무엇: 내부 버퍼의 T* 반환.

    복잡도: O(1)

    구현 포인트(중요): 연속 저장이므로 begin()과 동일한 주소. N==0일 때도 어떤 “유효하지만 역참조 불가” 포인터를 줄 수 있음(구현마다 nullptr일 수도, 아닐 수도). 역참조 금지만 지키면 비교/전달은 안전. constexpr, noexcept.

    begin() / end()

    무엇: 정방향 반복자(사실상 T* / T* + N).

    복잡도: O(1)

    구현 포인트: begin() == data(), end() == data() + N. 임의접근 반복, constexpr, noexcept.

    cbegin() / cend()

    무엇: 상수 반복자(const T* / const T* + N).

    복잡도: O(1)

    구현 포인트: begin()/end()의 const 버전. constexpr, noexcept.

    rbegin() / rend()

    무엇: 역방향 반복자(std::reverse_iterator).

    복잡도: O(1)

    구현 포인트: rbegin()은 reverse_iterator(end()), rend()는 reverse_iterator(begin()). 포인터 래핑이라 가벼움. constexpr, noexcept.

    crbegin() / crend()

    무엇: const 역방향 반복자.

    복잡도: O(1)

    구현 포인트: 위의 const 버전. constexpr, noexcept.

    size()

    무엇: 원소 개수 반환(항상 N).

    복잡도: O(1)

    구현 포인트: 컴파일타임 상수 성격(대개 constexpr noexcept). 최적화에 유리.

    max_size()

    무엇: 수용 가능한 최대 개수(= N).

    복잡도: O(1)

    구현 포인트: size()와 동일. constexpr, noexcept.

    empty()

    무엇: 비었는지 여부 (N==0).

    복잡도: O(1)

    구현 포인트: constexpr, noexcept.

    fill(const T& value)

    무엇: 모든 원소를 value로 채움.

    복잡도: O(N)

    구현 포인트: 실질적으로 std::fill_n(begin(), N, value). T의 대입 비용/예외 여부가 그대로 반영.

    swap(array& other)

    무엇: 두 배열의 원소를 교환.

    복잡도: O(N) (요소별 스왑)

    구현 포인트(중요): 내부는 보통 std::swap_ranges(begin(), end(), other.begin()).

    T가 trivially swappable이면 사실상 memcpy급으로 최적화되기도 함(컴파일러/옵션 의존).

    noexcept는 std::is_nothrow_swappable_v<T>를 따라감.

    사용 팁 요약

    안전 인덱싱: 개발·검증 단계에선 at()로 방어, 핫패스에선 operator[] 사용 + 사전 검사.

    N==0 주의: front()/back()/operator[]는 UB. data()는 역참조 금지만 지키면 전달/비교 OK.

    반복자=포인터: 범용 알고리즘(std::sort, std::find 등)과 결합 시 오버헤드 최소.

    대량 채우기/교환: fill과 swap은 각각 O(N). T가 trivially copyable/swap 가능이면 매우 빠르게 최적화됨.


*/