/**
 *  @brief  A standard container using fixed-size memory allocation and
 *  constant-time manipulation of elements at either end.
 *
 *  @ingroup sequences
 *
 *  @tparam _Tp  Type of element.
 *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
 *
 *  Meets the requirements of a <a href="tables.html#65">container</a>, a
 *  <a href="tables.html#66">reversible container</a>, and a
 *  <a href="tables.html#67">sequence</a>, including the
 *  <a href="tables.html#68">optional sequence requirements</a>.
 *
 *  In previous HP/SGI versions of deque, there was an extra template
 *  parameter so users could control the node size.  This extension turned
 *  out to violate the C++ standard (it can be detected using template
 *  template parameters), and it was removed.
 *
 *  Here's how a deque<Tp> manages memory.  Each deque has 4 members:
 *
 *  - Tp**        _M_map
 *  - size_t      _M_map_size
 *  - iterator    _M_start, _M_finish
 *
 *  map_size is at least 8.  %map is an array of map_size
 *  pointers-to-@a nodes.  (The name %map has nothing to do with the
 *  std::map class, and @b nodes should not be confused with
 *  std::list's usage of @a node.)
 *
 *  A @a node has no specific type name as such, but it is referred
 *  to as @a node in this file.  It is a simple array-of-Tp.  If Tp
 *  is very large, there will be one Tp element per node (i.e., an
 *  @a array of one).  For non-huge Tp's, node size is inversely
 *  related to Tp size: the larger the Tp, the fewer Tp's will fit
 *  in a node.  The goal here is to keep the total size of a node
 *  relatively small and constant over different Tp's, to improve
 *  allocator efficiency.
 *
 *  Not every pointer in the %map array will point to a node.  If
 *  the initial number of elements in the deque is small, the
 *  /middle/ %map pointers will be valid, and the ones at the edges
 *  will be unused.  This same situation will arise as the %map
 *  grows: available %map pointers, if any, will be on the ends.  As
 *  new nodes are created, only a subset of the %map's pointers need
 *  to be copied @a outward.
 *
 *  Class invariants:
 * - For any nonsingular iterator i:
 *    - i.node points to a member of the %map array.  (Yes, you read that
 *      correctly:  i.node does not actually point to a node.)  The member of
 *      the %map array is what actually points to the node.
 *    - i.first == *(i.node)    (This points to the node (first Tp element).)
 *    - i.last  == i.first + node_size
 *    - i.cur is a pointer in the range [i.first, i.last).  NOTE:
 *      the implication of this is that i.cur is always a dereferenceable
 *      pointer, even if i is a past-the-end iterator.
 * - Start and Finish are always nonsingular iterators.  NOTE: this
 * means that an empty deque must have one node, a deque with <N
 * elements (where N is the node buffer size) must have one node, a
 * deque with N through (2N-1) elements must have two nodes, etc.
 * - For every node other than start.node and finish.node, every
 * element in the node is an initialized object.  If start.node ==
 * finish.node, then [start.cur, finish.cur) are initialized
 * objects, and the elements outside that range are uninitialized
 * storage.  Otherwise, [start.cur, start.last) and [finish.first,
 * finish.cur) are initialized objects, and [start.first, start.cur)
 * and [finish.cur, finish.last) are uninitialized storage.
 * - [%map, %map + map_size) is a valid, non-empty range.
 * - [start.node, finish.node] is a valid range contained within
 *   [%map, %map + map_size).
 * - A pointer in the range [%map, %map + map_size) points to an allocated
 *   node if and only if the pointer is in the range
 *   [start.node, finish.node].
 *
 *  Here's the magic:  nothing in deque is @b aware of the discontiguous
 *  storage!
 *
 *  The memory setup and layout occurs in the parent, _Base, and the iterator
 *  class is entirely responsible for @a leaping from one node to the next.
 *  All the implementation routines for deque itself work only through the
 *  start and finish iterators.  This keeps the routines simple and sane,
 *  and we can use other standard algorithms as well.
 */


/*

좋은 포인트예요. 연속 메모리가 아닌데도 operator[]/at가 O(1) 인 이유는, 
인덱스 → (노드 슬롯, 노드 내 오프셋) 으로 바꾸는 계산이 상수 시간의 간단한 산술 + 몇 번의 포인터 간접 참조만 필요하기 때문입니다. (자료 크기 n과 무관)

내부 아이디어

deque는

노드당 원소 수 = EPN = (sizeof(T) < 512) ? 512/sizeof(T) : 1

시작 이터레이터 _M_start가 들고 있는 값들:

_M_start._M_node : map의 현재 슬롯 주소 (T**)

_M_start._M_first : 현재 노드의 첫 원소 (T*)

_M_start._M_cur : 현재 첫 원소 위치 (T*)

인덱스 i번째 원소는, “시작점에서 i만큼 떨어진 위치”이므로

전체 오프셋 off = (_M_start._M_cur - _M_start._M_first) + i

몇 번째 노드로 갈지 node_advance = off / EPN

그 노드에서 몇 칸 들어가야 하는지 within = off % EPN

슬롯 찾기 slot = _M_start._M_node + node_advance // 타입: T**

해당 노드 시작 주소 base = *slot // 타입: T*

최종 주소 ptr = base + within // 타입: T*

이 일련의 계산은 정수 덧셈/나눗셈/나머지 + 2번의 포인터 간접 참조라서 항상 상수 시간입니다.

의사코드 (경계검사 없는 operator[])
reference operator[](size_type i) {
    const size_t EPN = __deque_buf_size(sizeof(T)); // 512/sizeof(T) 또는 1
    size_t off = (_M_start._M_cur - _M_start._M_first) + i;
    T** slot = _M_start._M_node + (off / EPN);
    T*  base = *slot;                 // 노드 시작 주소
    return *(base + (off % EPN));     // 최종 원소 참조
}

at(i)는 어떻게 다를까?

위와 동일한 계산 전에 if (i >= size()) throw std::out_of_range(...) 를 하고,

이후 같은 상수 시간 경로로 주소를 계산합니다.
→ 따라서 at(i)도 O(1) (추가로 size()는 O(1)이며, 예외 검사만 들어갑니다).

왜 포인터 뛰어넘기가 가능한가?

map(포인터 배열)이 노드들의 시작 주소(T*)를 들고 있고, 이터레이터는 그 map 슬롯 자체를 가리키는 T**를 보유합니다.

인덱스에서 정수 나눗셈으로 “몇 번째 슬롯인지” 바로 결정 → 슬롯 역참조로 해당 노드 시작 주소 획득 → 노드 내 오프셋 더하면 끝.

어디까지나 몇 번의 포인터 계산이라, 길이가 커져도 시간은 늘지 않습니다.

참고/주의

operator[]는 범위 검사를 하지 않으니 UB 위험(잘못된 인덱스).

at()는 예외를 던져 안전.

EPN이 2의 거듭제곱이 아닐 수도 있어요(예: sizeof(T)=6 → 85). 그래도 정수 나눗셈/나머지는 상수 시간이므로 O(1)입니다.

음수 인덱스는 표준 인터페이스에 없고, size_type는 부호 없는 정수입니다.

요약하면: (시작에서의 상대 오프셋) → (노드 번호, 노드 내 오프셋) 으로 바꾸는 산술만 하면 되고, 
그 뒤엔 슬롯 한 번 역참조해서 원소 주소에 바로 도달하므로 O(1)입니다.

*/

/*

ChatGPT의 말:

네. 한 줄로 말하면 맞습니다.

push_front: _M_cur가 **감소하는 방향(낮은 주소)**로 한 칸 이동해서 거기에 새 원소를 놓습니다.

push_back: _M_cur가 **증가하는 방향(높은 주소)**로 한 칸 이동해서 새 원소를 놓습니다.

조금 더 구조적으로 보면:

노드 경계 정의

한 노드(블록)는 연속 T 배열입니다.

이터레이터 필드:

_M_first : 노드의 첫 원소 주소 (T*)

_M_last : 노드의 끝 직후 주소 (T*) → half-open [first, last)

_M_cur : 현재 커서 (T*), 항상 _M_first <= _M_cur <= _M_last

노드 크기(원소 수) = elements_per_node (EPN)

push_back 동작

여유가 있으면 ( _M_finish._M_cur != _M_finish._M_last ):

현재 _M_finish._M_cur 자리에 배치/대입 후,

_M_finish._M_cur++ ← 오른쪽(높은 주소)으로 전진

여유가 없으면 (노드 꽉 참):

뒤쪽 map 슬롯 여유 확인, 없으면 map 확장/재배치

새 노드 할당, map 뒤 슬롯에 연결

_M_finish._M_node를 다음 슬롯으로 옮기고,

_M_finish._M_first/_M_last를 새 노드 경계로 맞춘 뒤,

_M_finish._M_cur = _M_first 에서 배치/대입, 이후 _M_cur++

=> 결과적으로 배치 주소는 증가 방향으로 진행됩니다.

push_front 동작

여유가 있으면 ( _M_start._M_cur != _M_start._M_first ):

--_M_start._M_cur ← 왼쪽(낮은 주소)으로 후퇴 먼저 하고,

그 위치에 배치/대입

여유가 없으면 (노드의 앞쪽이 꽉 참):

앞쪽 map 슬롯 여유 확인, 없으면 map 확장/재배치

새 노드 할당, map 앞 슬롯에 연결

_M_start._M_node를 이전 슬롯으로 옮기고,

_M_start._M_first/_M_last를 새 노드 경계로 맞춘 뒤,

보통 _M_start._M_cur = _M_last; --_M_cur; 로 노드의 맨 뒤 칸으로 커서를 두고,

그 위치에 배치/대입

=> 결과적으로 배치 주소는 감소 방향으로 진행됩니다.

간단 의사코드
// back
if (_M_finish._M_cur != _M_finish._M_last) {
    construct_at(_M_finish._M_cur, value);
    ++_M_finish._M_cur;
} else {
    reserve_map_at_back_if_needed();  // map 확장 가능
    allocate_and_link_new_node_at_back();
    set_finish_to_new_node_first();   // _M_first/_M_last 갱신, _M_cur = _M_first
    construct_at(_M_finish._M_cur, value);
    ++_M_finish._M_cur;
}

// front
if (_M_start._M_cur != _M_start._M_first) {
    --_M_start._M_cur;
    construct_at(_M_start._M_cur, value);
} else {
    reserve_map_at_front_if_needed();
    allocate_and_link_new_node_at_front();
    set_start_to_new_node_last();     // _M_first/_M_last 갱신, _M_cur = _M_last
    --_M_start._M_cur;                // 한 칸 당겨서
    construct_at(_M_start._M_cur, value);
}

back/front의 위치 감각

front()는 항상 *_M_start._M_cur

back()은 항상 *(_M_finish._M_cur - 1) (끝 이터레이터는 one-past-the-end)

emplace_*도 동일

emplace_back/emplace_front도 커서 이동 방향은 동일하고, “대입” 대신 그 위치에 **제자리 생성(placement new)**을 수행한다는 점만 다릅니다.

복잡도 요약

push_back/push_front : 아몰타이즈드 O(1)
(노드/맵 확장 시 추가 비용; 빈도가 낮아 평균 상수 시간)

*/

/*

거의 맞지만, 뒤쪽은 한 칸 보정이 필요해요.

*_M_start._M_cur ⇒ front() (비어있지 않을 때)

*_M_finish._M_cur ⇒ one-past-the-end 이라서 back()이 아님

back() 은 *(_M_finish._M_cur - 1) 에 해당

즉,

front() ≅ *begin() ≅ *_M_start._M_cur

back() ≅ *(end() - 1) ≅ *(_M_finish._M_cur - 1)

주의:

컨테이너가 빈 경우 *_M_start._M_cur나 *(_M_finish._M_cur - 1) 모두 역참조하면 UB입니다. (빈 덱은 보통 노드 1개를 유지하지만, start == finish라 역참조 불가)

노드 경계를 넘나드는 증감은 이터레이터가 _M_set_node로 처리하고, end()는 항상 “마지막 원소의 다음 위치”를 가리키도록 유지됩니다.

*/

/*

각 포인터의 정확한 타입

_M_cur : T* — “현재 원소”를 가리키는 포인터

_M_first : T* — “현재 노드 배열의 첫 원소”를 가리키는 포인터

_M_last : T* — “현재 노드 배열의 끝 ‘직후’”를 가리키는 포인터(즉, one-past-the-end)

_M_node : T** — map 배열에서 “현재 노드의 슬롯”을 가리키는 포인터

*(_M_node)의 타입은 T* 입니다. 즉, “현재 노드 배열의 시작 주소(=첫 원소 포인터)”를 담고 있어요.

즉,

*_M_cur → 현재 원소(T&)

*(_M_node) → 현재 노드의 시작 주소(T*)

여기서 중요한 오해 방지:

T->_M_cur 같은 건 아닙니다. T는 원소 타입(예: int, MyStruct)이고, _M_cur/_M_first/_M_last/_M_node는 이터레이터 객체의 멤버예요.

올바른 접근은 it._M_cur, it._M_node처럼 “이터레이터”의 멤버로 접근하는 형태(물론 실제 코드는 private이라 직접 못 건드림).

왜 _M_node가 T**인가?

“map”은 노드(=T의 작은 배열)의 시작 포인터들(T*)을 쭉 모아둔 배열입니다.

타입으로 쓰면 대략 T* map[...];

이터레이터는 그 배열의 “현재 슬롯”을 가리켜야 하므로 슬롯을 가리키는 포인터가 필요 → T**(=슬롯의 주소).

그래서 *(_M_node) 하면, 그 슬롯에 들어있는 값(=현재 노드의 시작 포인터 T*)을 얻습니다.

노드 경계 세팅(핵심 루틴 개념)

노드를 바꿀 때(예: ++ 하다 경계를 넘었을 때) 보통 이런 식으로 경계를 다시 맞춥니다(의사 코드):

void _M_set_node(T** new_node_slot) {
    _M_node  = new_node_slot;      // map의 새로운 슬롯(T**)
    _M_first = *new_node_slot;     // 슬롯에 든 값은 T* (노드의 시작)
    _M_last  = _M_first + elements_per_node; // 노드의 끝 직후
    // _M_cur는 호출하는 쪽에서 적절히 배치(예: 새 노드의 첫 원소나 끝 직전 등)
}


여기서 elements_per_node = (sizeof(T) < 512) ? 512/sizeof(T) : 1 라는 규칙을 씁니다.

증감 연산 시 흐름 예시
++it

++_M_cur;

만약 _M_cur == _M_last(노드 경계 넘어섬)라면:

_M_set_node(_M_node + 1); // 다음 map 슬롯로 이동

_M_cur = _M_first; // 새 노드의 첫 원소로 커서 재설정

--it

만약 _M_cur == _M_first(현재 노드의 첫 원소를 지나 뒤로 가려는 경우):

_M_set_node(_M_node - 1); // 이전 map 슬롯로 이동

_M_cur = _M_last; // 새 노드의 끝 직후로 맞추고

--_M_cur; // 한 칸 뒤로 실제 이동

원소 접근과 타입 감각

현재 원소 참조: *_M_cur → 타입은 T&

현재 노드의 시작 주소: *(_M_node) → 타입은 T*

다음 노드로 “점프”: _M_node + 1 (슬롯 이동), 거기서 *(_M_node + 1) 하면 다음 노드의 시작 T*

경계: _M_first <= _M_cur < _M_last 를 유지

아주 작은 그림
map:   [ 0 ]     [ 1 ]     [ 2 ]     [ 3 ]    ...
        |         |         |         |
       T*0       T*1       T*2       T*3      (각각 노드 배열의 시작 주소)

iterator:
  _M_node  ---> &map[1]   (타입 T**)
  *_M_node == map[1] == T*1
  _M_first == T*1
  _M_last  == T*1 + elements_per_node
  _M_cur   == T*1 + k      (노드 내 오프셋 k)


요약:

*_M_node의 타입은 T* (노드 시작 포인터)이고, *_M_cur의 타입은 T&(현재 원소).

T->_M_cur 같은 표기는 잘못된 상상(멤버가 T에 있는 게 아니라 이터레이터에 있습니다).

이터레이터는 T 3개 + T* 1개**로 “노드 경계 정보 + 현재 위치”를 들고 다니며, 노드 경계를 넘을 때는 _M_set_node(_M_node ± 1)로 다음/이전 노드로 “점프”합니다.

*/

/*

핵심 내부 모델(요약)

저장소: 여러 노드(T의 작은 배열) + 이를 가리키는 map(T**).

이터레이터: T* 3개(_M_cur/_M_first/_M_last) + T** 1개(_M_node).

컨테이너는 내부에 항상 두 이터레이터를 멤버로 가짐: _M_start, _M_finish.

범위/크기: 사실상 size() == _M_finish - _M_start (O(1)).

함수별 설명 + 시간복잡도
assign(...)

역할: 기존 내용을 지우고, 지정한 개수/범위/초기값으로 재채움.

복잡도: O(n) (n = 결과 원소 수).

비고: 기존 노드 재사용/추가 할당이 섞일 수 있음.

at(size_type i)

역할: 경계 검사가 있는 인덱스 접근. 범위를 벗어나면 std::out_of_range.

복잡도: O(1).

비고: 내부적으로 _M_start 기준으로 노드/오프셋 계산.

back()

역할: 마지막 원소 참조.

복잡도: O(1).

비고: _M_finish._M_cur - 1 위치를 참조.

begin() / end()

역할: 시작/끝 이터레이터 값 복사 반환(힙 할당 없음).

복잡도: O(1).

비고: 내부 멤버 _M_start/_M_finish를 그대로 반환(복사).

cbegin() / cend(), crbegin() / crend(), rbegin() / rend()

역할: 상수/역방향 이터레이터 반환.

복잡도: O(1).

clear()

역할: 모든 원소 파괴.

복잡도: O(n) 파괴.

비고: 구현에 따라 최소 1개 노드를 남기기도 함(다음 삽입 최적화).

emplace(pos, args...)

역할: pos 위치에 원소를 제자리 생성(중간 삽입 포함).

복잡도: O(min(pos, n-pos)) (가까운 쪽 끝으로 당기며 이동) + 생성/이동 비용.

비고: 가운데 삽입은 데크 특성상 대량 이동이 생김.

emplace_back(args...) / emplace_front(args...)

역할: 뒤/앞에 원소 제자리 생성.

복잡도: 아몰타이즈드 O(1). 새 노드/맵 확장 시 약간 더 듦.

비고: 아래 “push/pop 내부 동작” 참고(동일한 경로에서 생성만 다름).

empty()

역할: 비었는지.

복잡도: O(1).

erase(pos) / erase(first, last)

역할: 원소(범위) 삭제.

복잡도: 단일 원소/짧은 구간은 O(min(k, n-k)) (k=지우는 구간의 중앙까지 거리). 범위는 O(지우는개수 + 이동개수).

원리: 가까운 쪽 끝 방향으로 블록 이동(시프트)하여 구멍 메움 → 필요 시 노드 해제.

front()

역할: 첫 원소 참조.

복잡도: O(1).

비고: _M_start._M_cur 위치 참조.

get_allocator()

역할: 사용 중인 할당자 반환.

복잡도: O(1).

insert(pos, value/ count / range)

역할: 삽입(중간 포함).

복잡도: O(min(pos, n-pos) + m) (m=삽입 개수).

원리: 가까운 쪽 끝으로 데이터 이동 후 빈자리 생성 → 값/범위 채움.

max_size()

역할: 컨테이너가 담을 수 있는 최대 원소수(이론상 상한) 반환.

복잡도: O(1).

operator=(...)

역할: 대입(복사/이동/이니셜라이저리스트).

복잡도: 복사 O(n), 이동 O(1)~O(n) (노드 재사용 정도에 따라).

operator[](size_type i)

역할: 경계 검사 없는 인덱스 접근.

복잡도: O(1).

pop_back() / pop_front()

역할: 뒤/앞에서 원소 제거.

복잡도: 아몰타이즈드 O(1).

비고: 원소 파괴 후, 노드가 비면 노드 해제 및 이터레이터 갱신.

push_back(const T& / T&&) / push_front(const T& / T&&)

역할: 뒤/앞에 원소 추가.

복잡도: 아몰타이즈드 O(1) (노드/맵 확장 시만 더 듦).

상세 원리는 아래 “push/pop 내부 동작(깊게)” 참고.

resize(new_size) / resize(new_size, value)

역할: 크기 조정. 늘리면 기본값/value로 채움, 줄이면 파괴.

복잡도: O(|new_size - old_size|) 추가 생성/파괴.

shrink_to_fit()

역할: 여유 노드/맵 공간 회수 시도(비보장).

복잡도: 구현 의존. 일반적으로 **O(n)**까지 갈 수 있음.

비고: “요청”일 뿐 반드시 축소되리라 보장 X.

size()

역할: 원소 개수.

복잡도: O(1) (_M_finish - _M_start).

swap(deque& other)

역할: 두 컨테이너 내용 맞교환.

복잡도: O(1) (포인터/메타데이터 스왑).

push/pop 내부 동작(깊게)

아래는 libstdc++ 전형 구현 흐름(이름은 실제 소스와 1:1 일치할 수도 있고 아닐 수도 있지만, 구조는 동일합니다).

push_back(x) (또는 emplace_back(args...))

공간 확인

현재 노드의 끝 전( _M_finish._M_cur != _M_finish._M_last )이면, 노드 안 여유가 있음 → 그 자리에 배치/대입.

여유가 없으면(노드 꽉 참):
a. map의 뒤쪽 슬롯 여유 확인 → 없다면 _M_reserve_map_at_back로 map 재배치/확장(필요 시 새 map 할당, 
기존 노드 포인터 복사, _M_start/_M_finish 업데이트).
b. 새 노드 할당(_M_allocate_node) 후, map의 뒤쪽 슬롯에 노드 포인터 연결.
c. _M_finish._M_node를 다음 슬롯으로 이동하고, _M_finish._M_first/_M_last/_M_cur를 새 노드 경계로 재설정.

실제 기록

*_M_finish._M_cur = value (또는 배치 생성).

_M_finish._M_cur++ (커서 한 칸 전진).

복잡도: 아몰타이즈드 O(1). 가끔 새 노드/맵 확장 때문에 더 비싸질 수 있음.

push_front(x) (또는 emplace_front(args...))

공간 확인

현재 앞 노드에 여유( _M_start._M_cur != _M_start._M_first )가 있으면 앞쪽으로 한 칸 이동 후 기록.

없으면:
a. map의 앞쪽 슬롯 여유 확인 → 없으면 _M_reserve_map_at_front로 확장/재배치.
b. 새 노드 할당 후, map의 앞쪽 슬롯에 연결.
c. _M_start._M_node를 이전 슬롯으로 이동하고, _M_start._M_first/_M_last/_M_cur를 
새 노드의 끝으로 맞춤(앞에 넣을 것이므로 보통 _M_last에서 한 칸 뒤로 이동하는 형태).

실제 기록

--_M_start._M_cur 후 그 위치에 value 배치/대입.

복잡도: 아몰타이즈드 O(1).

pop_back()

_M_finish._M_cur가 노드의 시작보다 크면: --_M_finish._M_cur; → 원소 파괴.

만약 현재 노드에서 마지막 원소를 뺐고 노드가 비면:

노드 해제(_M_deallocate_node) 및 _M_finish._M_node를 이전 슬롯으로 되돌리고, 
경계 포인터들( _M_first/_M_last/_M_cur )을 그 노드의 끝으로 재설정.

복잡도: 아몰타이즈드 O(1).

pop_front()

_M_start._M_cur가 노드의 끝 이전이면: *_M_start._M_cur 파괴 후 ++_M_start._M_cur.

노드가 비면:

그 노드 해제 후 _M_start._M_node를 다음 슬롯으로 이동, 경계 포인터를 새 노드의 시작으로 재설정.

복잡도: 아몰타이즈드 O(1).

이터레이터/참조 무효화(중요 요약)

끝에서 push/pop:

보통 참조/포인터는 유지되지만, 이터레이터는 무효화될 수 있음(특히 맵 재할당이 일어나면 모든 이터레이터 무효화).

중간 insert/erase:

대체로 많은 이터레이터가 무효화(표준은 데크가 vector보다 더 엄격하게 무효화된다고 기억해 두면 좋습니다).

map 재할당(노드가 아닌 map 자체 확장):

모든 이터레이터가 무효화될 수 있음.

실무 팁

끝에서만 쌓고 빼면(큐/덱 사용) 데크는 아주 효율적입니다(아몰타이즈드 O(1)).

가운데 삽입/삭제가 잦으면 std::list나 다른 구조 고려.

operator[]/at는 O(1)이지만 연속 메모리는 아님: 대량의 범위 알고리즘(예: std::sort)은 불가. 대신 std::sort는 vector에만.

*/


/*

요약하면: begin()/end()는 매 호출 때 “새 이터레이터 객체를 heap에 만들지 않고”, 
컨테이너 안에 이미 들고 있는 내부 이터레이터를 값으로 “복사해” 반환합니다. 
값 복사라서 포인터 4개짜리 작은 구조 복사 정도(O(1))예요.

실제 코드:
begin() → return this->_M_impl._M_start; / end() → return this->_M_impl._M_finish;

( const 버전 및 cbegin()/cend()도 동일 )

이 내부 이터레이터 두 개(_M_start, _M_finish)는 컨테이너 객체의 멤버로 항상 유지됩니다.

이터레이터 구조는 _M_cur/_M_first/_M_last(모두 T*)와 _M_node(map 슬롯 가리키는 T**)로 이루어진 4포인터입니다. 
따라서 복사는 저 4포인터 복사뿐이죠.

reverse 계열은 호출 시점에 reverse_iterator(_M_finish) / reverse_iterator(_M_start)를 
즉석에서 만들어 반환합니다(이것도 값 객체).

컨테이너가 구조를 바꿀 때는 내부의 _M_start/_M_finish를 적절히 업데이트하므로, 그다음 begin()/end()는 항상 “최신 상태의 복사본”을 줍니다(초기화 시점 예시: _M_start/_M_finish의 노드/커서 재설정).

참고로 size()도 그냥 finish - start로 계산되는 걸 보면, 이 내부 이터레이터 두 개가 “현재 범위”를 표현하고 있음을 알 수 있어요.

정리

begin()/end() = 내부 멤버 이터레이터의 값 복사 반환(힙 할당 없음).

이터레이터는 포인터 4개짜리 경량 구조체라 복사 비용이 매우 작음.

컨테이너 갱신 시 _M_start/_M_finish를 갱신 → 이후 begin()/end()는 항상 최신 스냅샷을 리턴.

*/

/*

구현적 특징

메모리 구조(비연속 블록 + 포인터 배열)
연속 메모리가 아니라, 여러 개의 **노드(node = T의 작은 배열)**를 두고, 이를 가리키는 map(Tp) 배열로 관리합니다. 노드 크기는 원소 크기와 반비례하여 “작고 거의 일정”하게 유지되도록 설계되어, 할당자 효율을 높입니다.

노드당 원소 수(배열 크기)
내부 상수 512를 사용해 elements_per_node = (sizeof(T) < 512) ? 512/sizeof(T) : 1 로 결정합니다(튜너블하지만 ABI 영향).

초기 배치와 확장 방식
초기 map 크기는 최소 8이고, 필요한 노드 수를 계산해 map의 가운데부터 배치하여 양쪽 끝으로 확장 여지를 둡니다.

생성/파괴 흐름
노드 할당은 __deque_buf_size(sizeof(T))만큼의 원소 공간을 한 번에 잡고, 소멸 시에는 노드들을 모두 해제하고 마지막에 map을 해제합니다.

빈 컨테이너/경계 조건 불변식
빈 컨테이너라도 항상 한 개의 노드를 보유합니다. 시작/끝(start, finish) 이터레이터는 항상 “유효(non-singular)”합니다.

양 끝 상수 시간 조작 + 이터레이터가 ‘점프’
실제 노드 간 도약(leap)은 이터레이터가 담당합니다. 구현 루틴은 start/finish 이터레이터만을 통해 동작하므로, 비연속 저장소를 상위 로직이 의식할 필요가 없습니다.

map 확장(재할당) 시 고려
새 노드가 더 필요하고 map 끝 여유가 없으면 map 재할당이 발생합니다(이 과정은 map 포인터, 따라서 이터레이터에 영향 가능).

사용하는 포인터들(구조와 역할)

노드 포인터(_Elt_pointer = T*)
이터레이터가 들고 있는 현재 원소/노드 경계 포인터:
_M_cur(현재 원소), _M_first(노드의 첫 원소), _M_last(노드의 끝 직후) → 모두 T*.

맵 포인터(_Map_pointer = T**)
이터레이터의 _M_node는 **실제 노드가 아니라 “map의 한 칸”**을 가리킵니다. 즉, _M_node(T**)를 역참조하면 해당 노드(T*)의 시작 주소를 얻습니다.

컨테이너 보유 포인터들
본체는 Tp** _M_map, size_t _M_map_size, 그리고 이 두 값을 참조하는 이터레이터 _M_start/_M_finish를 멤버로 둡니다.

할당자 기반 포인터 별칭
내부 베이스 클래스는 할당자에서 재바인딩한 포인터 타입들을 사용합니다(_Ptr, _Ptr_const 등). 노드 할당/해제도 이 포인터 타입을 통해 수행합니다.

노드 간 ‘연결’ 방식
노드들끼리 직접 연결 리스트를 만들지 않습니다. **map(포인터 배열)**을 인덱싱해 다음/이전 노드로 이동하며, 이터레이터의 ++/--는 경계를 만나면 _M_set_node로 다음/이전 map 슬롯으로 이동합니다.

정리(짧은 요약)

**Tp 배열(노드)을 여러 개 두고, Tp* map으로 관리하는 비연속 저장소.

노드 크기: (sizeof(T) < 512) ? 512/sizeof(T) : 1 (최소 1 원소).

초기에는 map 가운데에 노드를 배치해 양쪽으로 확장하고, 필요 시 map 재할당도 수행.

이터레이터는 _M_cur/_M_first/_M_last (T*)와 _M_node (T**)를 들고 노드 경계를 건너뛰며 동작.

*/




/*

메모리 모델(정적? 힙?)

모두 동적(힙) 할당입니다. deque는 두 가지 메모리 덩어리를 씁니다:
map: “노드 포인터들의 배열”(Tp**), 2) node(블록): T가 여러 개 들어가는 작은 배열. 
각 노드는 allocate로 새로 할당되고, 소멸/clear 시 노드들을 해제하고 마지막에 map도 해제합니다.

추가 할당은 어떻게?
끝(front/back)으로 밀려 나가면 새 노드를 더 붙입니다. 여유가 부족하면 _reserve_elements_at_front/back → M_new_elements_at 경로로 필요 개수만큼 새 노드(배열)를 추가합니다.
map 자체 공간이 부족하면 map 재할당(확장)도 합니다. 이때 map 포인터(그리고 이터레이터)들이 무효화될 수 있음이 명시돼 있습니다.
초기 구성 시에도 필요한 노드 수만큼 할당하고, 그 포인터들을 map의 가운데부터 바깥으로 배치해 확장 여지를 둡니다.

“배열(노드)”의 크기는?
요소 개수 기준으로, elements_per_node = (sizeof(T) < 512) ? 512/sizeof(T) : 1 입니다. 즉 T가 작을수록 한 노드에 더 많이 들어가고, 아주 크면 노드당 1개만 담습니다.
예) int(4B)라면 노드당 128개, double(8B)라면 64개.

이터레이터는 어떻게 동작?
이터레이터는 현재 원소 포인터와 현재 노드의 경계를 함께 가집니다: _M_cur, _M_first, _M_last, _M_node. 증감 연산 시 노드 경계를 넘으면 _M_set_node로 다음/이전 노드로 점프합니다(랜덤 접근 이터레이터).

“배열과 배열(노드와 노드) 사이는 어떻게 연결?”
노드끼리 직접 연결하지 않습니다. 대신 **map(포인터 배열)**이 각 노드를 가리킵니다. 이터레이터의 node는 노드 그 자체가 아니라 map의 한 칸(즉 “노드 포인터를 담은 위치”)을 가리키며, 이를 통해 다음/이전 노드로 이동합니다(클래스 불변식에 명시).
즉 비연속(비연속 블록 + 포인터 인덱싱) 구조이며, 시작/끝은 항상 유효한 이터레이터로 유지됩니다.

구현적 특징 요약

양 끝 삽입/삭제가 상수 시간(노드 경계 상황에서도 노드 단위 추가/제거)로 설계됨.

저장소는 블록(노드) 단위로 분절되어 있어 연속 메모리 보장은 없음(vector와 차이). map은 최소 크기 8로 시작, 가운데에서 바깥으로 성장.

추가 확장 시: 노드 추가(필요 수만), 그리고 map 공간이 모자라면 map 재할당 → 이터레이터 무효화 가능.

노드 크기 규칙은 고정 상수 512를 바탕으로 512/sizeof(T)(최소 1요소)로 계산 → 할당자 효율과 캐시 효율을 노린 설계.

소멸 시 요소 파괴 → 노드 해제 → map 해제 순으로 깔끔하게 정리.

*/