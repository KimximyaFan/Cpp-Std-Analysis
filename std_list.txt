/**
   *  @brief A standard container with linear time access to elements,
   *  and fixed time insertion/deletion at any point in the sequence.
   *
   *  @ingroup sequences
   *
   *  @tparam _Tp  Type of element.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and a
   *  <a href="tables.html#67">sequence</a>, including the
   *  <a href="tables.html#68">optional sequence requirements</a> with the
   *  %exception of @c at and @c operator[].
   *
   *  This is a @e doubly @e linked %list.  Traversal up and down the
   *  %list requires linear time, but adding and removing elements (or
   *  @e nodes) is done in constant time, regardless of where the
   *  change takes place.  Unlike std::vector and std::deque,
   *  random-access iterators are not provided, so subscripting ( @c
   *  [] ) access is not allowed.  For algorithms which only need
   *  sequential access, this lack makes no difference.
   *
   *  Also unlike the other standard containers, std::list provides
   *  specialized algorithms %unique to linked lists, such as
   *  splicing, sorting, and in-place reversal.
   *
   *  A couple points on memory allocation for list<Tp>:
   *
   *  First, we never actually allocate a Tp, we allocate
   *  List_node<Tp>'s and trust [20.1.5]/4 to DTRT.  This is to ensure
   *  that after elements from %list<X,Alloc1> are spliced into
   *  %list<X,Alloc2>, destroying the memory of the second %list is a
   *  valid operation, i.e., Alloc1 giveth and Alloc2 taketh away.
   *
   *  Second, a %list conceptually represented as
   *  @code
   *    A <---> B <---> C <---> D
   *  @endcode
   *  is actually circular; a link exists between A and D.  The %list
   *  class holds (as its only data member) a private list::iterator
   *  pointing to @e D, not to @e A!  To get to the head of the %list,
   *  we start at the tail and move forward by one.  When this member
   *  iterator's next/previous pointers refer to itself, the %list is
   *  %empty.
   * 
컨테이너 성격: std::list는 이중 연결 리스트. 원소 접근은 선형 시간(O(n)), 어느 위치든 삽입/삭제는 상수 시간(O(1)).

임의 접근 없음: 랜덤 액세스 이터레이터가 없어서 operator[], at() 제공 안 함. 알고리즘은 순차 접근 전제.

요구사항 충족: 표준의 container / reversible container / sequence 요구사항(선택적 시퀀스 요구 포함) 충족.

전용 알고리즘: 연결 리스트 특화 기능 제공 — splice(스플라이스), sort(제자리 정렬), reverse(제자리 반전).

메모리/할당자 포인트: 실제로 Tp 자체가 아니라 List_node<Tp> 노드를 할당.
다른 할당자를 쓰는 리스트 간 splice 후에도 각 리스트가 자기 방식대로 파괴/해제 가능(할당자 규약에 부합).

원형(sentinel) 구조: 내부적으로 원형 리스트(센티널 노드). 클래스는 꼬리(센티널) 위치를 가리키는 이터레이터 하나만 보관하고, 
머리는 그 다음 노드. 센티널의 next/prev가 자기 자신이면 빈 리스트.

템플릿 인자: std::list<T, Alloc>에서 Alloc은 할당자 타입, 기본은 std::allocator<T>

네, “꼬리(tail) 위치의 센티널 노드를 가리키는 이터레이터(end())를 내부에 들고 있다”**는 뜻이야.
실제 데이터 원소 D 자체를 가리키는 게 아니라, **마지막과 처음 사이에 끼어 있는 숨은 노드(센티널)**를 가리킨다고 보면 정확해.
구조 요약 (libstdc++의 std::list)
내부에 원형 이중연결 리스트 + 센티널 노드 하나를 둠.
리스트가 비어 있으면: sentinel->next == sentinel 그리고 sentinel->prev == sentinel.
공개 API 관점:
end() → 센티널을 가리키는 이터레이터
begin() → std::next(end()) (센티널의 다음 = 첫 원소)
마지막 원소 이터레이터 → std::prev(end())
front() = *begin(), back() = *std::prev(end())
즉, 주석의 “D”는 리스트의 꼬리 위치에 있는 센티널을 뜻한다고 이해하면 돼.
그래서 “머리(A)로 가려면 꼬리(D)에서 한 칸 앞으로 가라” → begin() = ++end()가 되는 것






좋아, std::list 전용 3개 연산을 무엇을 하는지 + 시간복잡도만 딱 잡아줄게.

splice (스플라이스)

무엇: 다른 리스트(또는 같은 리스트)의 노드들을 복사 없이 링크만 갈아끼워 현재 리스트의 pos 앞에 붙임. 원소 생성/소멸 없음 → 빠름.

복잡도:

전체 이동 splice(pos, other) → O(1). 
en.cppreference.com

단일 노드 splice(pos, other, it) → O(1). 
en.cppreference.com

구간 이동 splice(pos, other, first, last) →

같은 리스트에서의 재배치면 O(1),

다른 리스트에서 가져오면 O(k) (k = distance(first,last)) — 보통 크기 갱신 때문에 개수 세야 해서. 
en.cppreference.com

주의: 두 리스트의 할당자 비교가 같지 않으면 UB(표준 요구). 이때는 스플라이스 못 한다고 보면 됨. 
en.cppreference.com

sort (제자리 정렬)

무엇: 리스트 자체를 안정 정렬(stable) 함. std::sort는 랜덤액세스 이터레이터가 필요해서 리스트엔 못 씀 → list::sort를 써야 함. 
en.cppreference.com

복잡도: 약 O(N log N) 비교 (비교자 쓰면 그 호출도 O(N log N)). 이터레이터/참조 무효화 안 됨. 
en.cppreference.com

reverse (제자리 반전)

무엇: 리스트의 순서를 뒤집음. 링크를 전부 뒤집어야 하므로 각 노드를 한 번씩 만짐.

복잡도: O(N), 이터레이터/참조 무효화 안 됨. 
cppreference.patrickfasano.com
+1

작게 예시:

std::list<int> a = {1,2,3}, b = {10,20,30};

// splice
auto pos = std::next(a.begin());     // 2 앞에
a.splice(pos, b);                    // b의 모든 노드를 a로 (O(1))

// sort
a.sort();                            // 안정 정렬, O(N log N)

// reverse
a.reverse();



액세스/반복자
front() / back() : 첫/마지막 원소 참조. O(1)
begin() / end() : 앞/끝(센티널) 이터레이터. O(1)
용량
empty() : 비었는지. O(1)
size() : 원소 수. 보통 O(1)(현대 구현)
수정(삽입/삭제/생성)
push_front(x) / push_back(x) : 앞/뒤에 삽입. O(1)
emplace_front(args...) / emplace_back(args...) / emplace(pos, args...) : 자리에서 생성. O(1)(pos까지 가는 비용 제외)
insert(pos, x) : pos 앞에 삽입. O(1)(pos까지 가는 비용 제외)
pop_front() / pop_back() : 앞/뒤 하나 삭제. O(1)
erase(it) : it 가리키는 원소 삭제. O(1)
erase(first,last) : 구간 삭제. O(distance(first,last))
clear() : 전부 삭제. O(n)
assign(count, x) / assign(first,last) : 새 내용으로 교체. O(n)
리스트 전용 연산
splice(pos, other) / splice(pos, other, it) / splice(pos, other, first, last)
: 노드 링크만 갈아끼워 다른 리스트(또는 자기 자신) 구간을 옮김(복사/이동 생성 없음).
O(1)(전체/단일 노드). 구간은 O(k)(k개 노드 이동).
⚠️ 동일 타입 + 같은 allocator(또는 같은 PMR resource) 가 아니면 UB.
remove(value) / remove_if(pred) : 값/조건에 맞는 원소 모두 삭제. O(n)
unique() : 연속된 중복 원소 제거(인접한 것만). O(n)
merge(other) : 정렬된 두 리스트를 안정 병합하여 자기 리스트에 연결. O(n)
⚠️ 두 리스트가 같은 비교 기준으로 정렬되어 있어야 함.
sort() : 리스트 자체 안정 정렬. O(n log n)
reverse() : 순서 뒤집기(링크만 반전). O(n)
swap(other) : 두 리스트 교환. O(1)
이터레이터/참조 무효화 규칙 (중요)
삭제된 원소의 이터레이터/참조만 무효화됨.
insert/emplace/push/splice/merge/sort/reverse 후에도 다른 원소들의 이터레이터/참조는 유효(순서만 바뀔 수 있음).
splice/merge로 다른 리스트로 옮겨진 노드의 이터레이터는 여전히 유효하지만, 소속 컨테이너가 바뀜.


한 번 찾아놓으면” 그 뒤의 조작이 매우 싸다(O(1))**는 게 핵심


언제 std::list가 이득인가 (실전 예시)
LRU 캐시 (대표 예시)
키→노드 이터레이터를 unordered_map에 저장.
히트 시 그 노드를 splice로 맨 앞에 O(1) 이동.
축출 시 맨 뒤 pop_back O(1).
스케줄러 / 타임휠 / 작업 큐
작업 제출 시 리스트에 노드 추가하고, 그 이터레이터를 핸들로 보관.
취소/우선순위 변경 시 해당 이터레이터로 erase/splice → O(1).
벡터는 중간 지우기/이동이 O(n)이고 iterator도 자주 무효화됨.
“연결”만 갈아끼우는 병합/이동
이미 정렬된 두 리스트를 merge(안정) O(n) 로 연결(대형 객체 복사 없음).
여러 큐 사이에서 덩어리(구간)를 **splice(pos, other, first, last) O(k)**로 이동(복사/이동 생성 없음).
원소 주소(참조) 안정성 필요
vector는 재할당/중간 삽입에 기존 참조·포인터가 깨짐.
list는 지운 노드만 무효화되고, 나머지 참조/포인터/이터레이터는 평생 유효(순서만 변할 수 있음).
엔진/그래프 구조에서 여러 곳이 같은 객체 주소를 쥐고 있는 상황에 유리.
예: Scene이 Entity를 리스트에 두고, 여러 시스템이 포인터로 참조.
큰/이동 비용 큰 타입, 비이동 타입
list는 재배치 시 값 자체를 옮기지 않고 링크만 수정 → 대형/복잡 객체에 유리.
“복사/이동 불가” 객체도 emplace_*로 자리에 생성해두면 이후 재배치는 splice로 O(1).
자주 앞/중간에 삽입/삭제
위치만 알아내면 삽입/삭제 O(1). (탐색 비용은 별도)
패턴이 “순회하면서 조건 맞는 곳에서 바로 지움/옮김”일 때 강력.
(예: 필터링하면서 remove_if/splice)
간단 연결 자료구조/프리리스트
프리블록 목록, 이벤트 체인, undo/redo 같은 데서
노드 제거/삽입이 O(1)이고 구현이 직관적.
제자리 알고리즘 제공
reverse() O(n) — 값 이동 없이 링크만 반전.
sort() O(n log n) — 안정 정렬, 값 이동 없이 링크 재조합.
unique() — 인접 중복 제거 O(n) (링크 수정만).

짚고 가자:
탐색과 **조회(역참조)**는 다릅니다.
탐색(find/인덱스 i까지 걷기) → 노드를 타고 가야 하므로 O(n)
조회(이미 가진 이터레이터 it로 *it 읽기) → 그 노드를 직접 가리키고 있어 O(1)
왜 O(1)인가?
이터레이터의 원리(핵심)
std::list의 이터레이터는 사실상 “노드 포인터”의 얇은 래퍼

언제 O(n)이 되나?
그 노드의 이터레이터가 없을 때 (인덱스로 접근, 값으로 검색 등):
begin()에서부터 걸어가야 하므로 O(n).
그래서 실무에선 키 → 이터레이터를 unordered_map에 저장해
찾기 O(1) + 조작 O(1) 패턴(LRU 등)을 씁니다.
유효성(중요 포인트)
std::list는 지운 노드의 이터레이터만 무효화됩니다.
insert/splice/reverse/sort/merge 등으로 순서가 바뀌어도 그 노드 이터레이터는 여전히 유효(단, 소속 컨테이너가 바뀔 수 있음).
지운 노드를 가리키는 이터레이터를 쓰면 UB입니다.
요약: 이터레이터는 그 노드의 주소를 들고 있으니, 찾는 과정만 빼면 **조회/삽입/삭제가 전부 O(1)**입니다. 탐색이 필요할 때만 O(n)
  */



/*
   Node Base

   _List_node_base는 prev/next 두 포인터만 가진 베이스.
리스트는 헤더 노드(센티널) 를 갖고, 비었을 때 head->next == head->prev == &head.
표준 연산과 1:1로 매핑되는 저수준 포인터 조작기.
요약 표
swap(_List_node_base& x, _List_node_base& y): 두 헤더 노드가 가리키는 리스트 내용을 통째로 O(1)에 맞바꿈. 
std::list::swap의 핵심. (빈 리스트/비비 아닌 경우를 분기)

_M_hook(_List_node_base* pos): this 노드를 pos 앞에 끼워 넣음. = 단일 노드 insert.

_M_unhook(): this 노드를 현재 리스트에서 빼내기. 이웃끼리 서로 물어주고 this는 고립됨. = 단일 노드 erase의 핵심.
_M_transfer(_List_node_base* first, _List_node_base* last): 반열린 구간 [first, last) 를 
this 노드 앞으로 통째로 이동(스플라이스). 구간 길이와 무관하게 O(1). std::list::splice의 핵심.
_M_reverse(): 헤더(보통 this가 헤더일 때) 기준 리스트의 순서를 뒤집기. 모든 노드의 next/prev를 맞바꿈.


// Supporting structures are split into common and templated
// types; the latter publicly inherits from the former in an
// effort to reduce code duplication.  This results in some
// "needless" static_cast'ing later on, but it's all safe
// downcasting.

*/


/// Common part of a node in the %list.
struct _List_node_base
{
_List_node_base* _M_next;
_List_node_base* _M_prev;

static void
swap(_List_node_base& __x, _List_node_base& __y) _GLIBCXX_USE_NOEXCEPT;

void
_M_transfer(_List_node_base* const __first,
   _List_node_base* const __last) _GLIBCXX_USE_NOEXCEPT;

void
_M_reverse() _GLIBCXX_USE_NOEXCEPT;

void
_M_hook(_List_node_base* const __position) _GLIBCXX_USE_NOEXCEPT;

void
_M_unhook() _GLIBCXX_USE_NOEXCEPT;
};



/*
   Node Header
*/

/// The %list node header.
struct _List_node_header : public _List_node_base
{
#if _GLIBCXX_USE_CXX11_ABI
std::size_t _M_size;
#endif

_List_node_header() _GLIBCXX_NOEXCEPT
{ _M_init(); }

#if __cplusplus >= 201103L
_List_node_header(_List_node_header&& __x) noexcept
: _List_node_base{ __x._M_next, __x._M_prev }
# if _GLIBCXX_USE_CXX11_ABI
, _M_size(__x._M_size)
# endif
{
if (__x._M_base()->_M_next == __x._M_base())
this->_M_next = this->_M_prev = this;
else
{
   this->_M_next->_M_prev = this->_M_prev->_M_next = this->_M_base();
   __x._M_init();
}
}

void
_M_move_nodes(_List_node_header&& __x)
{
_List_node_base* const __xnode = __x._M_base();
if (__xnode->_M_next == __xnode)
_M_init();
else
{
   _List_node_base* const __node = this->_M_base();
   __node->_M_next = __xnode->_M_next;
   __node->_M_prev = __xnode->_M_prev;
   __node->_M_next->_M_prev = __node->_M_prev->_M_next = __node;
# if _GLIBCXX_USE_CXX11_ABI
   _M_size = __x._M_size;
# endif
   __x._M_init();
}
}
#endif

void
_M_init() _GLIBCXX_NOEXCEPT
{
this->_M_next = this->_M_prev = this;
#if _GLIBCXX_USE_CXX11_ABI
this->_M_size = 0;
#endif
}

private:
_List_node_base* _M_base() { return this; }
};


/*
   Actual Node
*/

/// An actual node in the %list.
template<typename _Tp>
struct _List_node : public __detail::_List_node_base
{
#if __cplusplus >= 201103L
__gnu_cxx::__aligned_membuf<_Tp> _M_storage;
_Tp*       _M_valptr()       { return _M_storage._M_ptr(); }
_Tp const* _M_valptr() const { return _M_storage._M_ptr(); }
#else
_Tp _M_data;
_Tp*       _M_valptr()       { return std::__addressof(_M_data); }
_Tp const* _M_valptr() const { return std::__addressof(_M_data); }
#endif
};


/*
   impl = “implementation(구현)” 의 줄임말
*/

struct _List_impl
: public _Node_alloc_type
{
__detail::_List_node_header _M_node;

_List_impl() _GLIBCXX_NOEXCEPT_IF(
   is_nothrow_default_constructible<_Node_alloc_type>::value)
: _Node_alloc_type()
{ }

_List_impl(const _Node_alloc_type& __a) _GLIBCXX_NOEXCEPT
: _Node_alloc_type(__a)
{ }

#if __cplusplus >= 201103L
_List_impl(_List_impl&&) = default;

_List_impl(_Node_alloc_type&& __a, _List_impl&& __x)
: _Node_alloc_type(std::move(__a)), _M_node(std::move(__x._M_node))
{ }

_List_impl(_Node_alloc_type&& __a) noexcept
: _Node_alloc_type(std::move(__a))
{ }
#endif
};



/*

#####  ####    ###   #   #  #####  
#      #   #  #   #  ##  #    #    
####   ####   #   #  # # #    #    
#      # #    #   #  #  ##    #    
#      #  #    ###   #   #    #    

####    ###    ####  #   #  
#   #  #   #  #      #  #   
####   #####  #      ###    
#   #  #   #  #      #  #   
####   #   #   ####  #   #  

####   #####   ####  #####  #   #  
#   #  #      #        #    ##  #  
####   ###    # ##     #    # # #  
#   #  #      #  #     #    #  ##  
####   #####   ####  #####  #   #  

#####  #   #  ####   
#      ##  #  #   #  
###    # # #  #   #  
#      #  ##  #   #  
#####  #   #  ####   

*/

/*
   Front
*/

// element access
/**
 *  Returns a read/write reference to the data at the first
 *  element of the %list.
 */
_GLIBCXX_NODISCARD
reference
front() _GLIBCXX_NOEXCEPT
{ return *begin(); }

/**
 *  Returns a read-only (constant) reference to the data at the first
 *  element of the %list.
 */
_GLIBCXX_NODISCARD
const_reference
front() const _GLIBCXX_NOEXCEPT
{ return *begin(); }

/*
   Back
*/

/**
 *  Returns a read/write reference to the data at the last element
 *  of the %list.
 */
_GLIBCXX_NODISCARD
reference
back() _GLIBCXX_NOEXCEPT
{
iterator __tmp = end();
--__tmp;
return *__tmp;
}

/**
 *  Returns a read-only (constant) reference to the data at the last
 *  element of the %list.
 */
_GLIBCXX_NODISCARD
const_reference
back() const _GLIBCXX_NOEXCEPT
{
const_iterator __tmp = end();
--__tmp;
return *__tmp;
}

/*
   Begin
*/

// iterators
/**
 *  Returns a read/write iterator that points to the first element in the
 *  %list.  Iteration is done in ordinary element order.
 */
_GLIBCXX_NODISCARD
iterator
begin() _GLIBCXX_NOEXCEPT
{ return iterator(this->_M_impl._M_node._M_next); }

/**
 *  Returns a read-only (constant) iterator that points to the
 *  first element in the %list.  Iteration is done in ordinary
 *  element order.
 */
_GLIBCXX_NODISCARD
const_iterator
begin() const _GLIBCXX_NOEXCEPT
{ return const_iterator(this->_M_impl._M_node._M_next); }


/*
   End
*/

/**
 *  Returns a read/write iterator that points one past the last
 *  element in the %list.  Iteration is done in ordinary element
 *  order.
 */
_GLIBCXX_NODISCARD
iterator
end() _GLIBCXX_NOEXCEPT
{ return iterator(&this->_M_impl._M_node); }

/**
 *  Returns a read-only (constant) iterator that points one past
 *  the last element in the %list.  Iteration is done in ordinary
 *  element order.
 */
_GLIBCXX_NODISCARD
const_iterator
end() const _GLIBCXX_NOEXCEPT
{ return const_iterator(&this->_M_impl._M_node); }





/*

 ####  #      #####   ###   ####   
#      #      #      #   #  #   #  
#      #      ###    #####  ####   
#      #      #      #   #  # #    
 ####  #####  #####  #   #  #  #   

*/


/*
   Clear

*  Erases all the elements.  Note that this function only erases
*  the elements, and that if the elements themselves are
*  pointers, the pointed-to memory is not touched in any way.
*  Managing the pointer is the user's responsibility.
*/

void
clear() _GLIBCXX_NOEXCEPT
{
   _Base::_M_clear();
   _Base::_M_init();
}

/*
   _M_clear()

   노드 자체 메모리는 잘 수거함,
   만약 포인터를 담았다면, 포인터가 가리키는건 못수거함
*/

template<typename _Tp, typename _Alloc>
void
_List_base<_Tp, _Alloc>::
_M_clear() _GLIBCXX_NOEXCEPT
{
   typedef _List_node<_Tp>  _Node;
   __detail::_List_node_base* __cur = _M_impl._M_node._M_next;
   while (__cur != &_M_impl._M_node)
   {
      _Node* __tmp = static_cast<_Node*>(__cur);
      __cur = __tmp->_M_next;
      _Tp* __val = __tmp->_M_valptr();
      #if __cplusplus >= 201103L
      _Node_alloc_traits::destroy(_M_get_Node_allocator(), __val);
      #else
      _Tp_alloc_type(_M_get_Node_allocator()).destroy(__val);
      #endif
      _M_put_node(__tmp);
   }
}

/*
   _M_init()
*/
void
_M_init() _GLIBCXX_NOEXCEPT
{ this->_M_impl._M_node._M_init(); }

/*
   this->_M_impl._M_node._M_init()
*/
void
_M_init() _GLIBCXX_NOEXCEPT
{
   this->_M_next = this->_M_prev = this;
   #if _GLIBCXX_USE_CXX11_ABI
   this->_M_size = 0;
   #endif
}




/*

#####   #   #   ####  #####  ####    #####
  #     ##  #  #      #      #   #     #  
  #     # # #   ###   ###    ####      #  
  #     #  ##      #  #      #  #      #  
#####   #   #   ####  #####  #   #     #  

*/

/**
 *  @brief  Inserts given value into %list before specified iterator.
 *  @param  __position  A const_iterator into the %list.
 *  @param  __x  Data to be inserted.
 *  @return  An iterator that points to the inserted data.
 *
 *  This function will insert a copy of the given value before
 *  the specified location.  Due to the nature of a %list this
 *  operation can be done in constant time, and does not
 *  invalidate iterators and references.
 */


/*
   _M_valptr
*/
struct _List_node : public __detail::_List_node_base
{
__gnu_cxx::__aligned_membuf<_Tp> _M_storage;
_Tp*       _M_valptr()       { return _M_storage._M_ptr(); }
}

/*
   _M_get_node
*/
typename _Node_alloc_traits::pointer
_M_get_node()
{ return _Node_alloc_traits::allocate(_M_impl, 1); }

 /*
   _M_create_node

   1) 메모리만 확보: _M_get_node()가 _Node용 원시 메모리를 할당합니다(아직 값은 없음). 컨테이너의 노드 풀/할당자를 통해 가져와요.
   2) 노드용 할당자 참조: 노드(링크 + 값 저장)를 관리하는 노드 전용 할당자를 꺼냅니다. 컨테이너가 allocator-aware이므로 new/delete 대신 이걸 써야 해요.
   3) 예외 안전 가드 설정(RAII): __guard는 소멸 시 __alloc.deallocate(__p, 1) 같은 걸 호출하는 스코프 가드.
      → 이후 생성 중 예외가 터지면 자동으로 메모리 회수(누수 방지).
   4) 값 생성(emplace): allocator_traits::construct로 노드 안의 값 위치(_M_valptr()가 가리키는 곳)에 자리 지정 생성(placement new).
 */
template<typename... _Args>
_Node*
_M_create_node(_Args&&... __args)
{
   auto __p = this->_M_get_node();
   auto& __alloc = _M_get_Node_allocator();
   __allocated_ptr<_Node_alloc_type> __guard{__alloc, __p};
   _Node_alloc_traits::construct(__alloc, __p->_M_valptr(),
            std::forward<_Args>(__args)...);
   __guard = nullptr;
   return __p;
}

/*
   insert(const_iterator __position, const value_type& __x)

   _M_hook(_List_node_base* pos): this 노드를 pos 앞에 끼워 넣음. = 단일 노드 insert.
*/

template<typename _Tp, typename _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::
#if __cplusplus >= 201103L
insert(const_iterator __position, const value_type& __x)
#else
insert(iterator __position, const value_type& __x)
#endif
{
   _Node* __tmp = _M_create_node(__x);
   __tmp->_M_hook(__position._M_const_cast()._M_node);
   this->_M_inc_size(1);
   return iterator(__tmp);
}

/*
   insert(const_iterator __position, value_type&& __x)
*/
/**
 *  @brief  Inserts given rvalue into %list before specified iterator.
 *  @param  __position  A const_iterator into the %list.
 *  @param  __x  Data to be inserted.
 *  @return  An iterator that points to the inserted data.
 *
 *  This function will insert a copy of the given rvalue before
 *  the specified location.  Due to the nature of a %list this
 *  operation can be done in constant time, and does not
 *  invalidate iterators and references.
*/
iterator
insert(const_iterator __position, value_type&& __x)
{ return emplace(__position, std::move(__x)); }

/*
   insert(const_iterator __p, initializer_list<value_type> __l)

   std::list는 각 원소 삽입이 포인터 연결 O(1)이지만, 원소를 k번 생성/복사(또는 이동) 해야 해서 총 k번의 작업이 듭니다.

   O(K)
*/
/**
 *  @brief  Inserts the contents of an initializer_list into %list
 *          before specified const_iterator.
 *  @param  __p  A const_iterator into the %list.
 *  @param  __l  An initializer_list of value_type.
 *  @return  An iterator pointing to the first element inserted
 *           (or __position).
 *
 *  This function will insert copies of the data in the
 *  initializer_list @a l into the %list before the location
 *  specified by @a p.
 *
 *  This operation is linear in the number of elements inserted and
 *  does not invalidate iterators and references.
 */
iterator
insert(const_iterator __p, initializer_list<value_type> __l)
{ return this->insert(__p, __l.begin(), __l.end()); }

/*
   insert(const_iterator __position, _InputIterator __first,
      _InputIterator __last)

   O(K)

   O(1) 하려면 splice 써야함
*/

/**
 *  @brief  Inserts a range into the %list.
 *  @param  __position  A const_iterator into the %list.
 *  @param  __first  An input iterator.
 *  @param  __last   An input iterator.
 *  @return  An iterator pointing to the first element inserted
 *           (or __position).
 *
 *  This function will insert copies of the data in the range [@a
 *  first,@a last) into the %list before the location specified by
 *  @a position.
 *
 *  This operation is linear in the number of elements inserted and
 *  does not invalidate iterators and references.
 */
template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
iterator
insert(const_iterator __position, _InputIterator __first, _InputIterator __last);






/*

#####   ####    ###    ####  #####
#       #   #  #   #  #      #
###     ####   #####   ###   ###
#       #  #   #   #      #  #
#####   #   #  #   #  ####   #####

*/

/*
   _M_const_cast

   같은 위치의 “일반 iterator”로 바꾸는 내부 유틸이에요.
   libstdc++에서 list 계열 이터레이터는 내부적으로 같은 노드 포인터를 공유하므로, 
   컨테이너 내부 구현 코드에선 위치만 필요할 때 const_iterator → iterator로 캐스팅해 쓰죠
*/
iterator
_M_const_cast() const _GLIBCXX_NOEXCEPT
{ return iterator(const_cast<__detail::_List_node_base*>(_M_node)); }

/*
   _M_erase
*/

// Erases element at position given.
void
_M_erase(iterator __position) _GLIBCXX_NOEXCEPT
{
   this->_M_dec_size(1);
   __position._M_node->_M_unhook();
   _Node* __n = static_cast<_Node*>(__position._M_node);
   #if __cplusplus >= 201103L
      _Node_alloc_traits::destroy(_M_get_Node_allocator(), __n->_M_valptr());
   #else
      _Tp_alloc_type(_M_get_Node_allocator()).destroy(__n->_M_valptr());
   #endif

   _M_put_node(__n);
}

/*
   erase(const_iterator __position)
*/

/**
 *  @brief  Remove element at given position.
 *  @param  __position  Iterator pointing to element to be erased.
 *  @return  An iterator pointing to the next element (or end()).
 *
 *  This function will erase the element at the given position and thus
 *  shorten the %list by one.
 *
 *  Due to the nature of a %list this operation can be done in
 *  constant time, and only invalidates iterators/references to
 *  the element being removed.  The user is also cautioned that
 *  this function only erases the element, and that if the element
 *  is itself a pointer, the pointed-to memory is not touched in
 *  any way.  Managing the pointer is the user's responsibility.
 */
template<typename _Tp, typename _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::
#if __cplusplus >= 201103L
erase(const_iterator __position) noexcept
#else
erase(iterator __position)
#endif
{
   iterator __ret = iterator(__position._M_node->_M_next);
   _M_erase(__position._M_const_cast());
   return __ret;
}

/*
   erase(const_iterator __first, const_iterator __last)

   while 문으로 계속 erase 돌림
*/

/**
 *  @brief  Remove a range of elements.
 *  @param  __first  Iterator pointing to the first element to be erased.
 *  @param  __last  Iterator pointing to one past the last element to be
 *                erased.
 *  @return  An iterator pointing to the element pointed to by @a last
 *           prior to erasing (or end()).
 *
 *  This function will erase the elements in the range @a
 *  [first,last) and shorten the %list accordingly.
 *
 *  This operation is linear time in the size of the range and only
 *  invalidates iterators/references to the element being removed.
 *  The user is also cautioned that this function only erases the
 *  elements, and that if the elements themselves are pointers, the
 *  pointed-to memory is not touched in any way.  Managing the pointer
 *  is the user's responsibility.
 */
#if __cplusplus >= 201103L
erase(const_iterator __first, const_iterator __last) noexcept
#else
erase(iterator __first, iterator __last)
#endif
{
   while (__first != __last)
      __first = erase(__first);

   return __last._M_const_cast();
}




/*

####   #   #   ####   #   #      #####  ####    ###   #   #  #####
#   #  #   #  #       #   #      #      #   #  #   #  ##  #    #
####   #   #   ###    #####      ####   ####   #   #  # # #    #
#      #   #      #   #   #      #      # #    #   #  #  ##    #
#      #####   ####   #   #      #      #  #    ###   #   #    #


####   #   #   ####   #   #      ####    ###    ####  #   #
#   #  #   #  #       #   #      #   #  #   #  #      #  #
####   #   #   ###    #####      ####   #####  #      ###
#      #   #      #   #   #      #   #  #   #  #      #  #
#      #####   ####   #   #      ####   #   #   ####  #   #


####    ###   ####        #####  ####    ###   #   #  #####
#   #  #   #  #   #       #      #   #  #   #  ##  #    #
####   #   #  ####        ####   ####   #   #  # # #    #
#      #   #  #           #      # #    #   #  #  ##    #
#       ###   #           #      #  #    ###   #   #    #


####    ###   ####        ####    ###    ####  #   #
#   #  #   #  #   #       #   #  #   #  #      #  #
####   #   #  ####        ####   #####  #      ###
#      #   #  #           #   #  #   #  #      #  #
#       ###   #           ####   #   #   ####  #   #

*/

/*
   _M_hook

   노드를 pos 앞에 끼워 넣음
*/
void
_List_node_base::
_M_hook(_List_node_base* const __position) _GLIBCXX_USE_NOEXCEPT
{
   this->_M_next = __position;
   this->_M_prev = __position->_M_prev;
   __position->_M_prev->_M_next = this;
   __position->_M_prev = this;
}

/*
   _M_insert
*/

template<typename... _Args>
void
_M_insert(iterator __position, _Args&&... __args)
{
   _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
   __tmp->_M_hook(__position._M_node);
   this->_M_inc_size(1);
}

// [23.2.2.3] modifiers
/**
 *  @brief  Add data to the front of the %list.
 *  @param  __x  Data to be added.
 *
 *  This is a typical stack operation.  The function creates an
 *  element at the front of the %list and assigns the given data
 *  to it.  Due to the nature of a %list this operation can be
 *  done in constant time, and does not invalidate iterators and
 *  references.
 */
void
push_front(const value_type& __x)
{ this->_M_insert(begin(), __x); }

#if __cplusplus >= 201103L
void
push_front(value_type&& __x)
{ this->_M_insert(begin(), std::move(__x)); }

/**
 *  @brief  Add data to the end of the %list.
 *  @param  __x  Data to be added.
 *
 *  This is a typical stack operation.  The function creates an
 *  element at the end of the %list and assigns the given data to
 *  it.  Due to the nature of a %list this operation can be done
 *  in constant time, and does not invalidate iterators and
 *  references.
 */
void
push_back(const value_type& __x)
{ this->_M_insert(end(), __x); }

#if __cplusplus >= 201103L
void
push_back(value_type&& __x)
{ this->_M_insert(end(), std::move(__x)); }

/**
 *  @brief  Removes first element.
 *
 *  This is a typical stack operation.  It shrinks the %list by
 *  one.  Due to the nature of a %list this operation can be done
 *  in constant time, and only invalidates iterators/references to
 *  the element being removed.
 *
 *  Note that no data is returned, and if the first element's data
 *  is needed, it should be retrieved before pop_front() is
 *  called.
 */
void
pop_front() _GLIBCXX_NOEXCEPT
{ this->_M_erase(begin()); }

/**
 *  @brief  Removes last element.
 *
 *  This is a typical stack operation.  It shrinks the %list by
 *  one.  Due to the nature of a %list this operation can be done
 *  in constant time, and only invalidates iterators/references to
 *  the element being removed.
 *
 *  Note that no data is returned, and if the last element's data
 *  is needed, it should be retrieved before pop_back() is called.
 */
void
pop_back() _GLIBCXX_NOEXCEPT
{ this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }





/*

#####  #   #  ####   #       ###    ####  #####
#      ## ##  #   #  #      #   #  #      #
####   # # #  ####   #      #####  #      ####
#      #   #  #      #      #   #  #      #
#####  #   #  #      #####  #   #   ####  #####


#####  #   #  ####   #       ##     ####  #####   ####   ###    ####  #   #
#      ## ##  #   #  #      #   #  #      #       #   # #   #  #      # # 
####   # # #  ####   #      #####  #      ####    ####  #####  #      ##  
#      #   #  #      #      #   #  #      #       #   # #   #  #      # #
#####  #   #  #      #####  #   #   ####  #####   ####  #   #   ####  #   #


#####  #   #  ####   #       ###    ####  #####   #####  ####   ###   #   #  #####
#      ## ##  #   #  #      #   #  #      #       #      #   # #   #  ##  #    #
####   # # #  ####   #      #####  #      ####    ####   ####  #   #  # # #    #
#      #   #  #      #      #   #  #      #       #      #  #  #   #  #  ##    #
#####  #   #  #      #####  #   #   ####  #####   #      #   #  ###   #   #    #




값(=완성된 객체)을 넣으려면 insert, 재료(생성자 인자)로 바로 만들어 넣으려면 emplace

*/

/*
   Emplace
*/
template<typename _Tp, typename _Alloc>
template<typename... _Args>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::
emplace(const_iterator __position, _Args&&... __args)
{
   _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
   __tmp->_M_hook(__position._M_const_cast()._M_node);
   this->_M_inc_size(1);
   return iterator(__tmp);
}

/*
   Emplace Front
*/
template<typename... _Args>
#if __cplusplus > 201402L
reference
#else
void
#endif
emplace_front(_Args&&... __args)
{
   this->_M_insert(begin(), std::forward<_Args>(__args)...);
   #if __cplusplus > 201402L
      return front();
   #endif
}

/*
   Empalce Back
*/
template<typename... _Args>
#if __cplusplus > 201402L
reference
#else
void
#endif
emplace_back(_Args&&... __args)
{
   this->_M_insert(end(), std::forward<_Args>(__args)...);
   #if __cplusplus > 201402L
      return back();
   #endif
}


/*

####   #####  #   #   ####   #     #  #####
#   #  #      ## ##  #    #  #     #  #
####   ###    # # #  #    #   #   #   ###
#  #   #      #   #  #    #    # #    #
#   #  #####  #   #   ####      #     #####


####   #####  #   #   ####   #     #  #####    ###  ######
#   #  #      ## ##  #    #  #     #  #         #   #
####   ###    # # #  #    #   #   #   ###       #   ###
#  #   #      #   #  #    #    # #    #         #   #
#   #  #####  #   #   ####      #     #####    ###  #




리스트를 순회하면서 *it == value인 노드들을 **O(1) splice**로 임시 리스트(__to_destroy)로 옮겨두고, 
루프가 끝난 뒤 임시 리스트가 스코프에서 파괴될 때 그 노드들이 한꺼번에 소멸/해제됩니다. C++20 모드에선 제거한 개수를 반환

*/


/*
*  @brief  Remove all elements equal to value.
*  @param  __value  The value to remove.
*
*  Removes every element in the list equal to @a value.
*  Remaining elements stay in list order.  Note that this
*  function only erases the elements, and that if the elements
*  themselves are pointers, the pointed-to memory is not
*  touched in any way.  Managing the pointer is the user's
*  responsibility.
*/

template<typename _Tp, typename _Alloc>
typename list<_Tp, _Alloc>::__remove_return_type
list<_Tp, _Alloc>::
remove(const value_type& __value)
{
   #if !_GLIBCXX_USE_CXX11_ABI
      size_type __removed __attribute__((__unused__)) = 0;
   #endif

   list __to_destroy(get_allocator());
   iterator __first = begin();
   iterator __last = end();

   while (__first != __last)
   {
      iterator __next = __first;
      ++__next;

      if (*__first == __value)
      {
         // _GLIBCXX_RESOLVE_LIB_DEFECTS
         // 526. Is it undefined if a function in the standard changes
         // in parameters?
         __to_destroy.splice(__to_destroy.begin(), *this, __first);
         #if !_GLIBCXX_USE_CXX11_ABI
            _GLIBCXX20_ONLY( __removed++ );
         #endif
      }

      __first = __next;
   }

   #if !_GLIBCXX_USE_CXX11_ABI
      return _GLIBCXX20_ONLY( __removed );
   #else
      return _GLIBCXX20_ONLY( __to_destroy.size() );
   #endif
}


/**
 *  @brief  Remove all elements satisfying a predicate.
 *  @tparam  _Predicate  Unary predicate function or object.
 *
 *  Removes every element in the list for which the predicate
 *  returns true.  Remaining elements stay in list order.  Note
 *  that this function only erases the elements, and that if the
 *  elements themselves are pointers, the pointed-to memory is
 *  not touched in any way.  Managing the pointer is the user's
 *  responsibility.
 */

template<typename _Tp, typename _Alloc>
template <typename _Predicate>
typename list<_Tp, _Alloc>::__remove_return_type
list<_Tp, _Alloc>::
remove_if(_Predicate __pred)
{
   #if !_GLIBCXX_USE_CXX11_ABI
      size_type __removed __attribute__((__unused__)) = 0;
   #endif

   list __to_destroy(get_allocator());
   iterator __first = begin();
   iterator __last = end();

   while (__first != __last)
   {
      iterator __next = __first;
      ++__next;
      if (__pred(*__first))
      {
         __to_destroy.splice(__to_destroy.begin(), *this, __first);
         #if !_GLIBCXX_USE_CXX11_ABI
            _GLIBCXX20_ONLY( __removed++ );
         #endif
      }
      __first = __next;
   }

   #if !_GLIBCXX_USE_CXX11_ABI
      return _GLIBCXX20_ONLY( __removed );
   #else
      return _GLIBCXX20_ONLY( __to_destroy.size() );
   #endif
}

/*

#####  #   #  ####   #####  #   #
#      ## ##  #   #    #     # #
###    # # #  ####     #      #
#      #   #  #        #      #
#####  #   #  #        #      #


 ####   ###   #####  #####
#        #       #   #
 ###     #      #    ###
    #    #     #     #
####    ###   #####  #####

*/

bool empty() const { return _M_next == this; }

/**  Returns the number of elements in the %list.  */
_GLIBCXX_NODISCARD
size_type
size() const _GLIBCXX_NOEXCEPT
{ return _M_node_count(); }


/*

#   #  #####  ####    ###   #####
## ##  #      #   #  #      #
# # #  ###    ####   #  ##  ###
#   #  #      #  #   #   #  #
#   #  #####  #   #   ###   #####




정렬돼 있는 두 std::list를 “비교 → 한 노드씩 splice”로 섞어 붙이는 내부 구현이에요. 
소 복사/이동 없이 포인터 재배선만 하므로 각 이동은 O(1), 전체는 비교 횟수 기준 O(n+m)

*/

/*
   _M_transfer

   노드 구간 [first, last) 를 this 노드(= 위치 노드) 앞으로 옮기는 저수준 스플라이스입니다.
   복사/이동 없이 포인터 재배선만 하므로 **상수 시간 O(1)**에 동작
*/

void
_List_node_base::
_M_transfer(_List_node_base * const __first,
_List_node_base * const __last) _GLIBCXX_USE_NOEXCEPT
{
   if (this != __last)
   {
      // Remove [first, last) from its old position.
      __last->_M_prev->_M_next  = this;
      __first->_M_prev->_M_next = __last;
      this->_M_prev->_M_next    = __first;

      // Splice [first, last) into its new position.
      _List_node_base* const __tmp = this->_M_prev;
      this->_M_prev                = __last->_M_prev;
      __last->_M_prev              = __first->_M_prev;
      __first->_M_prev             = __tmp;
   }
}




/**
 *  @brief  Merge sorted lists.
 *  @param  __x  Sorted list to merge.
 *
 *  Assumes that both @a __x and this list are sorted according to
 *  operator<().  Merges elements of @a __x into this list in
 *  sorted order, leaving @a __x empty when complete.  Elements in
 *  this list precede elements in @a __x that are equal.
 * 
 * 

   자기 자신과 머지 금지(자기 자신이면 no-op).
   같은 allocator인지 확인(달라서 노드 공유가 불가하면 보통 에러/UB 방지).
   _Finalize_merge는 RAII 도우미: 머지 도중 예외가 나더라도 사이즈/소속 등의 불변식을 맞춰주도록 마무리 역할을 합니다

   두 범위가 모두 남아있는 동안 진행.
   비교 결과 두 번째 리스트의 현재 원소가 더 작으면, 그 한 노드만 this의 __first1 앞으로 O(1) 이동:
   __next를 __first2에서 한 칸 증가시켜 [++__next]를 반열림 구간의 끝으로 써서 길이 1의 구간을 이동.
   _M_transfer(pos, first, last) = [first,last) 구간을 pos 앞으로 splice.
   그렇지 않으면 __first1만 한 칸 진행(안정적 머지: “<”일 때만 오른쪽에서 가져오므로 같을 때는 왼쪽 원소가 먼저 유지됨 → stable).
 */

template<typename _Tp, typename _Alloc>
void
list<_Tp, _Alloc>::
#if __cplusplus >= 201103L
merge(list&& __x)
#else
merge(list& __x)
#endif
{
   // _GLIBCXX_RESOLVE_LIB_DEFECTS
   // 300. list::merge() specification incomplete
   if (this != std::__addressof(__x))
   {
      _M_check_equal_allocators(__x);

      iterator __first1 = begin();
      iterator __last1 = end();
      iterator __first2 = __x.begin();
      iterator __last2 = __x.end();

      const _Finalize_merge __fin(*this, __x, __first2);

      while (__first1 != __last1 && __first2 != __last2)
      {
         if (*__first2 < *__first1)
         {
            iterator __next = __first2;
            _M_transfer(__first1, __first2, ++__next);
            __first2 = __next;
         }
         else
            ++__first1;
      }
         
      if (__first2 != __last2)
      {
         _M_transfer(__last1, __first2, __last2);
         __first2 = __last2;
      }
   }
}

void
merge(list& __x)
{ merge(std::move(__x)); }

/**
 *  @brief  Merge sorted lists according to comparison function.
 *  @tparam _StrictWeakOrdering Comparison function defining
 *  sort order.
 *  @param  __x  Sorted list to merge.
 *  @param  __comp  Comparison functor.
 *
 *  Assumes that both @a __x and this list are sorted according to
 *  StrictWeakOrdering.  Merges elements of @a __x into this list
 *  in sorted order, leaving @a __x empty when complete.  Elements
 *  in this list precede elements in @a __x that are equivalent
 *  according to StrictWeakOrdering().
 */

template<typename _StrictWeakOrdering>
void
merge(list&& __x, _StrictWeakOrdering __comp);

template<typename _StrictWeakOrdering>
void
merge(list& __x, _StrictWeakOrdering __comp)
{ merge(std::move(__x), __comp); }







/*

  ###    ####    ####   ###    ####   #   #
 #   #  #       #        #    #       ##  #
 #####   ###     ###     #    # ####  # # #
 #   #      #       #    #    #    #  #  ##
 #   #  ####    ####    ###    ####   #   #




기존 내용 전체를 새 내용으로 갈아끼우는 함수들

*/

/*
   _M_fill_assign
*/
template<typename _Tp, typename _Alloc>
void
list<_Tp, _Alloc>::
_M_fill_assign(size_type __n, const value_type& __val)
{
   iterator __i = begin();
   for (; __i != end() && __n > 0; ++__i, --__n)
      *__i = __val;
   if (__n > 0)
      insert(end(), __n, __val);
   else
      erase(__i, end());
}

/*
   _M_assign_dispatch
*/
template<typename _Tp, typename _Alloc>
template <typename _InputIterator>
void
list<_Tp, _Alloc>::
_M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
      __false_type)
{
   iterator __first1 = begin();
   iterator __last1 = end();
   for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
      *__first1 = *__first2;
   if (__first2 == __last2)
      erase(__first1, __last1);
   else
      insert(__last1, __first2, __last2);
}

/**
 *  @brief  Assigns a given value to a %list.
 *  @param  __n  Number of elements to be assigned.
 *  @param  __val  Value to be assigned.
 *
 *  This function fills a %list with @a __n copies of the given
 *  value.  Note that the assignment completely changes the %list
 *  and that the resulting %list's size is the same as the number
 *  of elements assigned.
 * 
 * 리스트를 크기 n 으로 만들고, 모든 원소를 val 복사본으로 채움
 */
void
assign(size_type __n, const value_type& __val)
{ _M_fill_assign(__n, __val); }

/**
 *  @brief  Assigns a range to a %list.
 *  @param  __first  An input iterator.
 *  @param  __last   An input iterator.
 *
 *  This function fills a %list with copies of the elements in the
 *  range [@a __first,@a __last).
 *
 *  Note that the assignment completely changes the %list and
 *  that the resulting %list's size is the same as the number of
 *  elements assigned.
 * 
 *    [first,last)**의 원소들을 복사해 현재 리스트 내용 전체를 교체
 *
 *    assign(first, last)의 first/last는 “다른 컨테이너(다른 리스트 포함)”의 이터레이터여도 됩니다
 */
#if __cplusplus >= 201103L
template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
void
assign(_InputIterator __first, _InputIterator __last)
{ _M_assign_dispatch(__first, __last, __false_type()); }

/**
 *  @brief  Assigns an initializer_list to a %list.
 *  @param  __l  An initializer_list of value_type.
 *
 *  Replace the contents of the %list with copies of the elements
 *  in the initializer_list @a __l.  This is linear in __l.size().
 * 
 *    중괄호 리스트로 전체를 교체
 */
void
assign(initializer_list<value_type> __l)
{ this->_M_assign_dispatch(__l.begin(), __l.end(), __false_type()); }






/*

#   #  #   #  #####   ###   #   #  #####
#   #  ##  #    #    #   #  #   #  #    
#   #  # # #    #    #   #  #   #  ###  
#   #  #  ##    #    #  ##  #   #  #    
 ###   #   #  #####   ### #  ###   #####

*/

/**
 *  @brief  Remove consecutive duplicate elements.
 *
 *  For each consecutive set of elements with the same value,
 *  remove all but the first one.  Remaining elements stay in
 *  list order.  Note that this function only erases the
 *  elements, and that if the elements themselves are pointers,
 *  the pointed-to memory is not touched in any way.  Managing
 *  the pointer is the user's responsibility.
 */
template<typename _Tp, typename _Alloc>
typename list<_Tp, _Alloc>::__remove_return_type
list<_Tp, _Alloc>::
unique()
{
   iterator __first = begin();
   iterator __last = end();

   if (__first == __last)
      return _GLIBCXX20_ONLY( 0 );

   #if !_GLIBCXX_USE_CXX11_ABI
      size_type __removed __attribute__((__unused__)) = 0;
   #endif

   list __to_destroy(get_allocator());
   iterator __next = __first;

   while (++__next != __last)
   {
      if (*__first == *__next)
      {
         __to_destroy.splice(__to_destroy.begin(), *this, __next);
         #if !_GLIBCXX_USE_CXX11_ABI
            _GLIBCXX20_ONLY( __removed++ );
         #endif
      }
      else
         __first = __next;

      __next = __first;
   }

   #if !_GLIBCXX_USE_CXX11_ABI
      return _GLIBCXX20_ONLY( __removed );
   #else
      return _GLIBCXX20_ONLY( __to_destroy.size() );
   #endif
}

/**
 *  @brief  Remove consecutive elements satisfying a predicate.
 *  @tparam _BinaryPredicate  Binary predicate function or object.
 *
 *  For each consecutive set of elements [first,last) that
 *  satisfy predicate(first,i) where i is an iterator in
 *  [first,last), remove all but the first one.  Remaining
 *  elements stay in list order.  Note that this function only
 *  erases the elements, and that if the elements themselves are
 *  pointers, the pointed-to memory is not touched in any way.
 *  Managing the pointer is the user's responsibility.
 */
template<typename _BinaryPredicate>
__remove_return_type
unique(_BinaryPredicate);





/*

 ####   #   #   #     ###   ####  
#       #   #   #    #   #  #   # 
 ###    #   #   #    #####  ####  
    #    # # # #     #   #  #      
 ####     #   #      #   #  #     

*/


/**
 *  @brief  Swaps data with another %list.
 *  @param  __x  A %list of the same element and allocator types.
 *
 *  This exchanges the elements between two lists in constant
 *  time.  Note that the global std::swap() function is
 *  specialized such that std::swap(l1,l2) will feed to this
 *  function.
 *
 *  Whether the allocators are swapped depends on the allocator traits.
 * 
   부 포인터 재배선만 하므로 O(1)
   두 리스트의 헤더(센티널) 노드를 맞바꿔서, 사실상 리스트 내용 전체를 통째로 교환합니다.
   원소 복사/이동 없음 → 이터레이터/참조는 유효하지만, 이제 상대 리스트 소속
   size 필드도 서로 교환
 */
void
swap(list& __x) _GLIBCXX_NOEXCEPT
{
   __detail::_List_node_base::swap(this->_M_impl._M_node,
            __x._M_impl._M_node);

   size_t __xsize = __x._M_get_size();
   __x._M_set_size(this->_M_get_size());
   this->_M_set_size(__xsize);

   _Node_alloc_traits::_S_on_swap(this->_M_get_Node_allocator(),
                  __x._M_get_Node_allocator());
}



/*

 ####   ###   ####   #####
#      #   #  #   #    #  
 ###   #   #  ####     #  
    #  #   #  #  #     #  
####    ###   #   #    #  

*/

/**
 *  @brief  Sort the elements.
 *
 *  Sorts the elements of this list in NlogN time.  Equivalent
 *  elements remain in list order.
 */
void
sort();

/**
 *  @brief  Sort the elements according to comparison function.
 *
 *  Sorts the elements of this list in NlogN time.  Equivalent
 *  elements remain in list order.
 */
template<typename _StrictWeakOrdering>
void
sort(_StrictWeakOrdering);





/*

 ####  ####   #       ###    ####  #####
#      #   #  #        #    #      #    
 ###   ####   #        #    #      #### 
    #  #      #        #    #      #    
####   #      #####   ###    ####  #####

*/

// [23.2.2.4] list operations
/**
 *  @brief  Insert contents of another %list.
 *  @param  __position  Iterator referencing the element to insert before.
 *  @param  __x  Source list.
 *
 *  The elements of @a __x are inserted in constant time in front of
 *  the element referenced by @a __position.  @a __x becomes an empty
 *  list.
 *
 *  Requires this != @a __x.
 */
void
#if __cplusplus >= 201103L
splice(const_iterator __position, list&& __x) noexcept
#else
splice(iterator __position, list& __x)
#endif
{
   if (!__x.empty())
   {
      _M_check_equal_allocators(__x);

      this->_M_transfer(__position._M_const_cast(),
            __x.begin(), __x.end());

      this->_M_inc_size(__x._M_get_size());
      __x._M_set_size(0);
   }
}



void
splice(const_iterator __position, list& __x) noexcept
{ splice(__position, std::move(__x)); }



/**
 *  @brief  Insert element from another %list.
 *  @param  __position  Const_iterator referencing the element to
 *                      insert before.
 *  @param  __x  Source list.
 *  @param  __i  Const_iterator referencing the element to move.
 *
 *  Removes the element in list @a __x referenced by @a __i and
 *  inserts it into the current list before @a __position.
 */
void
splice(const_iterator __position, list&& __x, const_iterator __i) noexcept


/**
 *  @brief  Insert range from another %list.
 *  @param  __position  Const_iterator referencing the element to
 *                      insert before.
 *  @param  __x  Source list.
 *  @param  __first  Const_iterator referencing the start of range in x.
 *  @param  __last  Const_iterator referencing the end of range in x.
 *
 *  Removes elements in the range [__first,__last) and inserts them
 *  before @a __position in constant time.
 *
 *  Undefined if @a __position is in [__first,__last).
 */
void
splice(const_iterator __position, list& __x, const_iterator __first,
   const_iterator __last) noexcept
{ splice(__position, std::move(__x), __first, __last); }





/*

####   #####  #   #  #####  ####    ####   #####
#   #  #      #   #  #      #   #  #       #
####   ###    #   #  ###    ####    ###    ###
#  #   #       # #   #      #  #       #   #
#   #  #####    #    #####  #   #  ####    #####

*/

/**
 *  @brief  Reverse the elements in list.
 *
 *  Reverse the order of elements in the list in linear time.
 */
void
reverse() _GLIBCXX_NOEXCEPT
{ this->_M_impl._M_node._M_reverse(); }