/*

이터레이터, 한 장 요약

정의: 컨테이너 요소에 포인터처럼 접근·이동하기 위한 “일반화된 포인터”. 
*it(역참조), ++it(이동), it1==it2(동등 비교) 같은 공통 인터페이스를 제공.

종류(카테고리): C++20 기준

contiguous ⊃ random_access ⊃ bidirectional ⊃ forward ⊃ input

아래로 갈수록 기능/성능(점프, 인덱싱)이 줄어듦.

네가 본 4개 컨테이너의 이터레이터 성격
컨테이너	이터레이터 카테고리	내부 저장	이터레이터에 실제로 담기는 것(보통)	이동 원리
std::vector<T>	contiguous (연속, 임의 접근)	힙의 연속 버퍼	원소 포인터 (T*)	++ → ptr += 1, it + k, it[i] 가능
std::string	contiguous (vector<char>와 동일)	SSO/힙의 연속 버퍼	문자 포인터 (char*)	위와 동일
std::array<T,N>	contiguous (정적, 연속)	객체 내부의 정적 배열	원소 포인터 (T*)	위와 동일
std::list<T>	bidirectional (양방향, 비연속)	노드(힙) + 링크	노드 포인터 래퍼(노드의 주소)	++ → node = node->next, -- → prev (인덱싱/점프 불가)

메모: MSVC 디버그 빌드처럼 “체크드 이터레이터”가 켜지면, 안전성 검사용으로 컨테이너 포인터/범위 정보 등을 추가로 들고 있을 수 있어(성능 대신 안전성).

“모두 동일한 이터레이터인가?”

아니요. 표면 API는 비슷하지만, 카테고리/성질/내부 표현이 다름.

vector/string/array → 연속 메모리 기반이라 “포인터 그 자체”와 동일하게 다룸. it+n, it2-it1, it[i] 가능.

list → 포인터 연산 불가, 오직 ++/--와 *만. 인덱싱, 임의 점프가 안 되는 것이 본질적 차이.

“이터레이터가 자료구조를 순회하는 원리”

공통: for (it = begin(); it != end(); ++it) { use(*it); }

연속형 컨테이너(vector/string/array):

begin() = 첫 원소의 주소, end() = 마지막 다음(one-past-end) 주소.

++it는 주소 + 1 (O(1)), it + k도 O(1).

연결형 컨테이너(list):

각 노드에 next/prev 링크.

++it는 다음 노드 포인터로 교체 (O(1)), it + k는 불가(반복 k번 필요, O(k)).

“이터레이터에 담긴 건 뭔지?”

vector/string/array: 거의 항상 생짜 포인터(또는 포인터와 동일한 간단한 래퍼).

그래서 sizeof(iterator) == sizeof(T*)인 경우가 많음.

임의 접근 연산이 가능한 이유가 여기에 있음.

list: 노드 포인터를 감싼 작은 객체. 역참조 시 node->value를 반환. 이동 시 node = node->next/prev.

유효성(무효화) 규칙 – 성능/버그 포인트

vector/string

재할당(reallocate) 발생(예: push_back로 capacity 초과, reserve/shrink_to_fit) → 모든 이터레이터/포인터/참조 무효화.

중간 erase/insert → 변경 지점부터 뒤쪽 이터레이터가 무효화될 수 있음.

array

크기 불변. 원소를 바꾸지 않는 한 이터레이터는 무효화되지 않음(컨테이너가 파괴/이동되면 예외).

list

노드 단위: 다른 노드의 삽입/삭제/splice에도 살아있는 노드의 이터레이터는 유효.

단, 지워진 노드의 이터레이터만 무효. 이 특성 때문에 “많은 중간 삽입/삭제”에 강함.

어떤 때 무엇을 쓰나 (실무 감각)

연속 스캔/인덱싱/랜덤 접근·SIMD·캐시 중요 → vector/string/array (contiguous)

대량 순회/산술 인덱스/알고리즘 최적화에 유리.

중간 삽입/삭제 많고, 이터레이터 안정성 필요 → list

단, 캐시/메모리 지역성은 나쁨. 순수 순회 성능은 보통 vector가 더 좋다.

보너스: 역방향/상수/어댑터

rbegin()/rend()는 역방향 반복자(내부에 정방향 반복자를 base로 보관하는 어댑터). *rbegin()이 마지막 원소.

const_iterator는 읽기 전용. cbegin()/cend()는 언제나 상수 반복자.

포인터 범위를 반복자로 쓸 수 있는 범용 알고리즘(std::sort, std::find 등)이 “이터레이터”의 진짜 힘.

한 줄씩 결론

같아 보이지만 다르다: vector/string/array는 contiguous(사실상 포인터), list는 bidirectional(노드 포인터).

순회 원리: 연속형은 포인터 산술, 연결형은 링크 따라가기.

이터레이터 안: 연속형은 원소 주소, 연결형은 노드 주소(+ 디버그 모드면 검사용 메타 정보).

성능/무효화 규칙을 알면: 언제 어떤 컨테이너/패턴이 빠른지 명확해진다.

*/