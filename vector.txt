#ifndef _STL_VECTOR_H / #define _STL_VECTOR_H 1
-> 헤더가드




#if __cplusplus >= 202002L
-> 컴파일러가 표준 매크로 __cplusplus로 사용 중인 C++ 표준 버전을 검사

#if __cplusplus >= 202002L
  // C++20 기능 사용(예: std::span, concepts 등)
#else
  // 하위 버전 대체 구현
#endif







#if _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
extern "C" void
__sanitizer_annotate_contiguous_container(const void*, const void*,
                                          const void*, const void*);
#endif

-> AddressSanitizer(ASan) 같은 런타임이 연속 컨테이너의 사용/유휴 구간을 추적하도록 알려 주는 런타임 훅 선언
std::vector는 [begin, end)는 사용 중, [end, capacity_end)는 여유 공간
ASan에 “여긴 아직 쓰면 안 됨(포이즌)”/“여기까지는 이제 사용 중(언포이즌)” 같은 상태 변화를 알리면, 경계를 한 칸 넘는 실수도 바로 잡아줌 예: v[size()]








_GLIBCXX_BEGIN_NAMESPACE_VERSION, _GLIBCXX_BEGIN_NAMESPACE_CONTAINER

-> libstdc++가 ABI/버전 호환을 위해 쓰는 네임스페이스 열기 매크로

namespace std {
  _GLIBCXX_BEGIN_NAMESPACE_VERSION      // inline namespace __8 { ... 같은 버전 네임스페이스
  _GLIBCXX_BEGIN_NAMESPACE_CONTAINER    // inline namespace __cxx11 { ... (컨테이너 ABI 전용)

  // std::vector 정의 본문

  _GLIBCXX_END_NAMESPACE_CONTAINER
  _GLIBCXX_END_NAMESPACE_VERSION
}

VERSION: libstdc++ 내부의 버전 네임스페이스(보통 inline) 를 열어줍니다. 구현이 바뀌어도 기존 ABI를 보존하거나 구분하기 위한 장치.
CONTAINER: 특히 컨테이너 계열에 대해 C++11 ABI 전환(__cxx11) 을 분리하기 위해 쓰이던 껍데기입니다(문자열/컨테이너 ABI 변경과 연관).
요지는: 표면상 우리는 std::vector를 쓰지만, 안쪽은 inline namespace로 버전이 구분되어 ABI 호환성을 유지한다는 것.







전처리기
#if <식>: 조건부 컴파일(정수 상수식 평가).
#ifdef MACRO: 매크로 정의 여부로 분기.
#endif: 조건부 블록 종료.
#define MACRO ...: 매크로 정의(상수/함수형 매크로 등).

#define USE_FAST 1

#ifdef USE_FAST
  void run_fast();
#else
  void run_slow();
#endif






template: 템플릿 정의/선언에 사용.
template<class T>
struct Box { T value; };



typename:
템플릿 파라미터 선언 시 class와 동치.
의존 이름이 타입임을 명시할 때 필수.
template<class T>
void f() {
  // T가 템플릿 파라미터이므로, T::value_type이 "타입"임을 알려야 함
  typename T::value_type x{};
}
T::value_type는 **“T가 담는 요소의 타입”**을 말하는 중첩 타입(alias/typedef) 입니다.
예) std::vector<int>의 value_type은 int, std::map<K,V>의 value_type은 std::pair<const K, V>.
템플릿 안에서 T는 아직 미정의 타입(의존 이름) 입니다.
컴파일러는 T::value_type이 “타입인지 값인지”를 미리 모름 → 타입임을 알려주는 키워드가 typename
무엇이 들어있나? (STL 관례)
대부분의 표준 컨테이너/이터레이터는 다음 연관 타입들을 갖습니다.
value_type : 요소 타입
reference : 참조 타입(보통 value_type&)
const_reference : 상수 참조 타입
pointer : 포인터 타입
difference_type : 이터레이터 간 거리 타입
iterator/const_iterator : 이터레이터 타입들
iterator_category(이터레이터 쪽)




typedef: 기존 타입에 별칭 제공(구식). C++11 이후엔 using 권장.
typedef unsigned long ulong_t;
using ulong_u = unsigned long;   // 권장




이 조합이 자주 보이는 이유:
template<class T>
struct Vec {
  typedef typename std::vector<T>::size_type size_type; // 의존 타입 별칭
};
typename은 “std::vector<T>::size_type이 타입이다”라고 파서에 알려 주는 용도고,
typedef(또는 using)는 그 타입에 별칭을 붙이는 용도입니다.







내부 저장 레이아웃(3포인터 구조)

_Vector_base::_Vector_impl_data 안에 _M_start / _M_finish / _M_end_of_storage 3개 포인터로 메모리를 관리
즉, [start, finish)가 유효 요소 구간, [finish, end_of_storage)는 여유(capacity)

정의: 연속 메모리 위에 놓인 가변 길이 동적 배열.

연속성 보장: &v[0]부터 sizeof(T)*size() 만큼 연속. data()는 C API와 바로 연동 가능한 포인터를 줌.










_GLIBCXX_ASAN_ANNOTATE_GROW(1);
요약하면 _GLIBCXX_ASAN_ANNOTATE_GROW(1)는 libstdc++의 std::vector가 ASan(AddressSanitizer)에게 
“지금부터 끝에 1개 분량의 영역을 ‘임시로 유효’로 쓸 거야”라고 알려주는 주석(애너테이션) 매크로예요. 
push_back 같은 경로에서 요소를 실제로 하나 만들기 직전에 호출됩니다. 요소 생성이 끝나면 바로 뒤이어 
**_GLIBCXX_ASAN_ANNOTATE_GREW(1)**가 호출되어 “그 1칸을 실제로 사용 완료”했다고 갱신합니다. 
이 패턴 덕분에 size 밖(capacity 안) 넘겨 접근을 ASan이 정확히 잡아낼 수 있어요. 
gcc.gnu.org
핵심 동작은 이렇게 구현됩니다:
매크로 정의
GROW(n)은 내부 RAII 가드 타입 **_Asan<>::_Grow**를 하나 생성합니다(생성자에서 “언포이즌=유효화”) 
→ 가드 소멸자에서 아직 사용하지 않은 분량은 **_S_shrink**로 되돌립니다(“포이즌=무효화”). 
**GREW(n)**은 가드 내부 카운터를 깎아 “이미 쓴 만큼은 되돌리지 말라”고 표시합니다. 
gcc.gnu.org
이 RAII가 실제로 ASan 런타임 훅 __sanitizer_annotate_contiguous_container(begin, end_storage, old_mid, new_mid)를 호출하여, 
컨테이너의 사용 구간 경계를 finish → finish+n으로 조정합니다. 
gcc.gnu.org
결과적으로 push_back의 “여유 있음” 경로는 보통 이런 형태가 됩니다:
_GLIBCXX_ASAN_ANNOTATE_GROW(1);
// 요소 생성
++finish;
_GLIBCXX_ASAN_ANNOTATE_GREW(1);
(실제 소스에도 이 순서로 존재합니다.) 
gcc.gnu.org
예외 안전성: 요소 생성 중 예외로 실패하면 가드 소멸자가 남은 분량을 자동으로 되돌려 경계를 원래대로 복구합니다(ASan 입장에서도 일관 유지). 
gcc.gnu.org
빌드 조건: 이 애너테이션들은 특정 빌드 매크로가 켜졌을 때만 활성화되고, 아니면 전부 빈(no-op) 매크로로 대체됩니다. 
gcc.gnu.org
요컨대, _GLIBCXX_ASAN_ANNOTATE_GROW(1)/GREW(1) 콤보는 vector가 size를 늘리며 
capacity 일부를 실제로 채우는 순간을 ASan에 정확히 알리기 위한 내부 장치입니다. 
사용자 코드에서 직접 쓸 일은 없고(내부 매크로), ASan로 디버깅할 때 vector 경계 버그를 더 잘 잡아내게 해주는 도우미










push_back(const T& x) (lvalue 복사 버전)

void push_back(const value_type& __x)
{
  if (_M_finish != _M_end_of_storage) {              // ➊ 여유 있음
    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
    _Alloc_traits::construct(_M_impl, _M_finish, __x);// ➋ 그 자리에서 '복사 생성'
    ++_M_finish;                                      // ➌ 끝 포인터 한 칸 전진
    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
  } else {                                            // ➍ 여유 없음
    _M_realloc_append(__x);                           //    재할당 + 맨 끝에 새로 붙임
  }
}


➋의 construct(...)가 바로 placement new로 “초기화되지 않은 저장소”에 객체를 그 자리에서 생성하는 호출이야. (앞서 네가 본 그 함수)

여기서는 인자가 __x (lvalue)이므로 복사 생성자가 사용돼.



push_back(T&& x) (rvalue 이동 버전)

void push_back(value_type&& __x) { emplace_back(std::move(__x)); }

이동 가능한 값이 들어오면 굳이 복사하지 말고, 그 자리에 바로 생성(emplace) 하도록 emplace_back으로 위임한다.
이렇게 하면 이동 생성자(or 적절한 생성자)가 골라져서 불필요한 임시/복사를 피할 수 있어.



push_back(const T&) : 복사해서 끝에 하나 붙임 (여유 없으면 재할당)
push_back(T&&) : 이동을 활용하려고 emplace_back(std::move(x))로 위임




내부적으로는 allocator_traits::construct → placement new로 “그 자리에서” 객체를 만든다.
여유 없으면 _M_realloc_append로 새 버퍼 만들고 요소들 “안전하게” 옮긴 뒤 새 요소를 생성

const T& (상수 lvalue 참조)
무엇: “읽기 전용 참조”. lvalue(이름 있는 객체)에도, 임시 객체(rvalue) 에도 바인딩됨.
효과
인자를 복사하지 않고 참조만 함 → 큰 객체를 읽기 전용으로 받을 때 좋음.
임시에 바인딩되면 수명 연장됨(함수 끝까지 살아있음).
제약: 가리키는 값을 바꿀 수 없음.
void foo(const std::string& s) { /* s 읽기만 */ }
std::string a = "hi";
foo(a);              // lvalue OK
foo(std::string("x"));// rvalue(임시) OK, 수명 연장


T&& (rvalue 참조)
무엇: “임시/이동 가능한 것(rvalue)에 바인딩”하는 참조.
효과
move 생성/대입을 활성화 → 비싼 복사를 피함.
lvalue에는 바로 못 바인딩(필요하면 std::move(lv)).
주의점
이름 붙은 rvalue 참조 변수 자체는 lvalue다 → 다시 rvalue로 쓰려면 std::move 필요.
const T&&는 거의 쓰지 않음(대부분의 move가 const에선 막힘).

std::move(x): 무조건 rvalue로 캐스트. “이 객체에서 자원 뺏어가도 좋아” 신호.
std::forward<T>(x): 원래 인자의 값범주 유지 전달. (템플릿 포워딩에서만 의미)

const + move: const T는 보통 이동 대상 아님. std::move(const T&)는 대개 복사로 귀결(이동 생성자가 T&&만 받기 때문).
수명 연장: const T&는 rvalue에 바인딩 시 수명 연장. T&&도 함수 인자로 받으면 그 인자 자체 수명은 함수 끝까지.
작은 타입(int, 작은 POD 등)은 그냥 값으로 받는 게 보통 더 단순하고 빠를 수 있음.

“읽기 전용, 크고 복사 비쌈” → const T&
“임시/소유권 이동 활용” → T&& 오버로드 제공 + 내부에서 이동 사용
“일반 템플릿으로 받았다가 그대로 넘김” → T&&(포워딩 참조) + std::forward
“작고 싸다(int 등)” → 값으로 받기

먼저, &는 두 가지가 전혀 다름
타입 문맥에서의 & : “lvalue 참조”를 뜻함.
예) int& r = x; → r은 x라는 이름 있는 값(lvalue) 를 가리킴.
표현식(식) 문맥에서의 & : “주소 연산자” (address-of).
예) &x → x의 주소값.
같은 기호지만 “타입에 붙으면 참조”, “식에 붙으면 주소연산자”라고 보면 편해.

그럼 &&는?
타입 문맥에서의 && : “rvalue 참조”.
→ “임시/더 이상 쓸 의도가 약한 값”에 바인딩하려고 만든 참조야.
표현식 문맥에서의 && : “논리 AND” (그리고).
→ 이건 완전히 다른 뜻.
즉, T&&는 “더 이상 원본을 유지할 필요가 없는(대개 임시) 대상을 소유권 이동(move) 용도로 붙잡는 손잡이”라고 생각하면 됨.

왜 굳이 rvalue 참조가 필요할까?
큰 객체를 함수에 넘길 때 복사는 비쌈 → 이동이 있으면 싸다.
이동을 쓰려면 “이 값은 훔쳐가도 된다(다신 안 쓸 거다)”는 신호가 필요 → 그 역할이 T&&.
벡터 재할당, 문자열 붙이기 등 성능 핵심에서 결정적.

void use_copy(const std::string& s);   // 복사 필요할 수도
void use_move(std::string&& s);        // 이동 사용하려고 받음
std::string a = "hello";
use_copy(a);                 // OK (lvalue)
use_copy(std::string("x"));  // OK (임시, 수명연장)
use_move(std::string("tmp"));// OK (임시 rvalue)
use_move(std::move(a));      // OK (a를 더 안 쓰겠다는 의사표시)



좋아, 한 줄씩 “무슨 뜻 + 왜 그렇게 했는지”로 풀어볼게요. 코드 원형은 대략 std::allocator/allocator_traits 경로에서 std::vector가 요소를 “메모리만 있는 자리”에 직접 생성할 때 쓰는 헬퍼입니다.

#if __cplusplus >= 201103L
template<typename _Up, typename... _Args>
__attribute__((__always_inline__))
void
construct(_Up* __p, _Args&&... __args)
noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
#endif

무엇을 하는 함수인가?

역할: 주소 __p가 가리키는 초기화되지 않은 저장소(uninitialized storage) 위치에 타입 _Up 객체를 그 자리에서(placement) 생성한다.

사용처: vector::emplace_back, 재할당 시 새 버퍼에 요소 “생성”, uninitialized_move/uninitialized_copy 내부 등.

한 줄씩 뜯기

#if __cplusplus >= 201103L

C++11 이상에서만 이 템플릿 버전을 사용 (가변 인자, noexcept, type traits가 필요함).

template<typename _Up, typename... _Args>

만들 타입 _Up과, 생성자에 전달할 임의 개수의 인자 형식들 _Args....

__attribute__((__always_inline__))

GCC/Clang 확장. 가능하면 꼭 인라인하라고 힌트를 줌(강제가 아닌 최적화 힌트).

void construct(_Up* __p, _Args&&... __args)

_Up* 위치 __p에 객체를 만든다.

_Args&&...는 포워딩 참조(forwarding references). 호출쪽 인자의 lvalue/rvalue 성질을 그대로 보존해 전달하려고 이렇게 받는다.

noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)

“이 함수가 던지지 않는다(noexcept)”의 조건부 지정.

즉, _Up이 인자 _Args...로 **예외 없이 생성 가능(nothrow constructible)**이면 이 함수도 noexcept(true)가 되고, 아니면 noexcept(false).

효과: vector가 예외 보장을 설계할 때, 혹은 이동/복사 선택(예: “이동이 nothrow면 이동, 아니면 복사”)에 이 정보가 전파돼 최적화/롤백 전략을 더 안전하게 선택할 수 있음.

본체:

::new((void *)__p) _Up(std::forward<_Args>(__args)...);


::new(... ) : 글로벌 placement new를 명시적으로 호출. (사용자 정의 operator new의 간섭을 피하려고 전역 범위 지정)

((void*)__p) : placement new의 시그니처가 void*를 받기 때문에 정확한 오버로드 선택을 위해 void*로 캐스팅.

_Up(std::forward<_Args>(__args)...) : 그 자리에서 _Up의 생성자 호출. std::forward로 perfect forwarding 수행 → rvalue는 rvalue로, lvalue는 lvalue로 전달되어 복사/이동 오버로드가 올바르게 선택됨.

왜 “placement new”를 쓰나?

vector는 메모리 할당과 객체 생성을 분리해서 다룸.

먼저 allocator로 원시 메모리만 확보(아직 생성자 안 돌림).

그런 다음 그 주소에 placement new로 “생성”을 수행.

이렇게 해야 재할당/성장/롤백 때 예외 안전성과 성능(불필요한 초기화 방지)을 확보할 수 있음.

전제 조건(중요)

__p는 _Up을 담을 만큼 **정렬(alignment)**과 크기가 맞는, 초기화되지 않은 저장소여야 함. (보통 allocator가 준 버퍼)

그렇지 않으면 UB.

요소 타입에 따라 어떤 이점?

_Args&&... + std::forward 덕분에 복사보다 이동 생성자가 있으면 이동이 선택됨.

noexcept(...)가 true이면 컨테이너는 재배치 시 이동을 더 공격적으로 사용(예외 안전을 해치지 않으니).

자주 받는 질문 포인트

Q: 왜 static_cast<void*>가 아니라 C-style (void*)?
A: 관용/레거시 스타일. 의미는 동일(placement new의 시그니처 맞추기).

Q: 왜 ::new에 전역 범위 연산자?
A: 클래스/네임스페이스 안에 우연히 같은 이름의 operator new가 있어도 글로벌 placement new를 확실히 선택하려고.

Q: 그럼 소멸은?
A: allocator_traits::destroy(alloc, p) 같은 경로로 p->~_Up() 호출해서 명시적으로 소멸. (해제는 그 다음에 allocator로)

한눈 요약

무엇: “이 주소에 _Up 객체를 이 인자들로 그 자리에서 만들어라”.

어떻게: placement new + perfect forwarding.

안전성: _Up 생성이 nothrow면 함수도 noexcept, 컨테이너 예외전략에 도움.

언제: vector가 새 버퍼에 요소를 “옮길/만들” 때 (emplace, 재할당 등).





C++에서 자바처럼 “참조 보관” 효과를 내고 싶다면 vector<Foo*> vector<unique_ptr<Foo>>
vector<shared_ptr<Foo>>, 또는 vector<reference_wrapper<Foo>> 같은 간접 레이어를 담아야 해요

재할당(reallocation)과 주소 안정성
vector<T>는 용량이 차면 더 큰 버퍼로 옮기며, 그 과정에서 요소들을 이동/복사합니다.
그래서 요소의 주소/참조/포인터가 무효화될 수 있어요

참조가 필요하면 포인터/스마트포인터를 담자

vector<unique_ptr<T>> : 단일 소유권, 이동만 허용

vector<shared_ptr<T>> : 공유 소유권

vector<T*> : 생명주기 직접 관리 필요(주의)

vector<reference_wrapper<T>> : 레퍼런스 흉내 (소유권 없음)