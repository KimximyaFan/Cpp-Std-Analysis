// Red-black tree class, designed for use in implementing STL
// associative containers (set, multiset, map, and multimap). The
// insertion and deletion algorithms are based on those in Cormen,
// Leiserson, and Rivest, Introduction to Algorithms (MIT Press,
// 1990), except that
//
// (1) the header cell is maintained with links not only to the root
// but also to the leftmost node of the tree, to enable constant
// time begin(), and to the rightmost node of the tree, to enable
// linear time performance when used with the generic set algorithms
// (set_union, etc.)
//
// (2) when a node being deleted has two children its successor node
// is relinked into its place, rather than copied, so that the only
// iterators invalidated are those referring to the deleted node.


/*

짧게 핵심부터:

*_unique(예: _M_insert_unique, std::map/set::insert)
→ 키가 이미 있으면 새 노드 안 만든다. 실패로 {it,false}(map/set) 반환.
→ 결과적으로 동일 키는 최대 1개만 존재. count(key)는 0 또는 1.

*_equal(예: _M_insert_equal, std::multimap/multiset::insert)
→ 같은 키가 있어도 항상 새 노드 하나 더 만든다.
→ 동일 키가 여러 노드로 중복 저장된다. count(key)는 그 노드 개수.

즉, 별도의 “카운트 필드”를 들고 있는 단일 노드 구조가 아니라,
표준 연관 컨테이너는 **“원소 1개 = 트리 노드 1개”**가 원칙입니다.
멀티 컨테이너는 같은 키가 들어올 때 노드를 추가하며, 그 결과가 count()에 반영돼요.

조금 더 자세히
1) 메모리/구조

*_unique: 동일 키 중복 금지 → 노드 1개만 유지.

*_equal: 동일 키 허용 → 동일 키마다 노드가 1개씩.
(따라서 중복이 많으면 메모리 사용량이 키 개수만큼 늘어납니다.)

2) 연산 결과 & 복잡도

count(key)

unique 컨테이너(map/set): O(log n), 결과는 0 또는 1.

multi 컨테이너(multimap/multiset): O(log n + k) (k = 해당 키 개수). 내부적으로 equal_range(key)의 구간 길이를 계산.

erase(key)

unique: 0 또는 1개 삭제.

multi: 해당 키 모두 삭제(반환값이 삭제된 수).

find/equal_range

multi에서 find는 “첫 번째 등가 원소” 하나만 가리킴.

여러 개를 다루려면 equal_range(key)로 [first,last) 구간을 받아 순회.

3) 삽입 위치(멀티의 경우)

구현체는 보통 lower_bound/upper_bound 기준으로 등가 키 뭉치의 앞/뒤 어느 쪽에 붙일지 선택합니다(힌트가 있으면 힌트 근처).

표준은 등가 원소 사이의 상대적 순서를 보장하지 않습니다(안정성 요구 없음).

예시로 감 잡기
std::set<int> s;         // unique
s.insert(10); s.insert(10);
s.size();        // 1
s.count(10);     // 1

std::multiset<int> ms;   // equal
ms.insert(10); ms.insert(10);
ms.size();       // 2  (노드 2개)
ms.count(10);    // 2

“카운트를 들고 있는 1노드”가 필요하다면?

표준 multiset/multimap 대신,
std::map<Key, int>(빈도저장)이나 boost::container::flat_map<Key,int> 같은 빈도 맵을 쓰세요.
그러면 키 1개당 노드 1개 + 빈도 필드로 중복을 집계할 수 있습니다

*/

/*

짧게 정리하면 예, O(1)입니다. (빈 컨테이너 예외 주의)

왜 O(1)인가?

begin() → 헤더가 leftmost(최소 노드)를 캐시하므로 상수 시간에 그 이터레이터를 돌려줍니다.

end() → 헤더(센티넬) 자체를 가리키는 상수 시간 반환.

최소 원소 → *c.begin() 이 바로 최소값이므로 상수 시간 접근.

최대 원소 →

auto it = c.end(); --it; 로 rightmost(최대 노드)로 가는 경로가 구현상 O(1) 입니다.

혹은 rbegin()(역방향 첫 원소)도 rightmost 를 바로 가리켜 O(1).

꼭 기억할 예외/주의

빈 컨테이너에서는 begin()==end() 이고, --end()는 UB(정의되지 않음) 입니다. (비지 않았을 때만 --end() 허용)

“최대/최소 구하기”를 알고리즘으로 돌리면(예: std::min_element) 당연히 O(n) 입니다.
컨테이너 구조가 이미 정렬돼 있으니 이터레이터 트릭을 써야 O(1)입니다.

한 줄 요약

begin, end, rbegin은 모두 O(1)

최소 = *begin() O(1), 최대 = *prev(end()) 또는 *rbegin() O(1)

단, 빈 컨테이너에서 --end() 금지.

*/

/*

짧게: 따로 배열/연결리스트 안 만듭니다.
std::map/set 이터레이터는 트리 노드의 부모/좌/우 포인터만 이용해서 중위(in-order) 순회를 합니다. 경계만 도와주는 헤더(센티넬) 가 있을 뿐입니다.

어떻게 한 칸씩 움직이나? (원리)

각 노드는 (parent, left, right) 를 갖고 있고, 헤더 H는 H.parent=루트, H.left=최소노드, H.right=최대노드 입니다. 이 상태에서:

++it (다음 원소 = 중위 후계자)

오른쪽 자식이 있으면: node = node->right; 한 뒤 그 서브트리의 가장 왼쪽까지 내려감.

오른쪽 자식이 없으면:
부모로 올라가며 내가 parent->left였던 지점의 부모를 만날 때까지 parent = parent->parent;
그 부모가 바로 후계자.
만약 끝까지 올라가 헤더를 만나면 end().

의사코드:

if (x->right) { x = x->right; while (x->left) x = x->left; }
else { auto y = x->parent; while (x == y->right) { x = y; y = y->parent; } x = y; } // y가 헤더면 end()

--it (이전 원소 = 중위 선행자)

왼쪽 자식이 있으면: node = node->left; 후 그 서브트리의 가장 오른쪽으로.

왼쪽 자식이 없으면:
부모로 올라가며 내가 parent->right였던 지점의 부모를 만날 때까지.
특수케이스: it==end()(=헤더)에서 --it 하면 최대 노드로 바로 감.

의사코드:

if (x == header) x = header->right; // --end() = max
else if (x->left) { x = x->left; while (x->right) x = x->right; }
else { auto y = x->parent; while (x == y->left) { x = y; y = y->parent; } x = y; }

배열/리스트가 없는 이유

메모리 비연속: 각 노드는 개별 할당되고 회전/재균형은 포인터 재연결만 하므로, 주소(=이터레이터)가 안정적입니다. 별도의 “연결리스트”를 유지할 필요가 없습니다.

헤더는 경계 표지판: begin()/end()/최소/최대를 O(1) 로 가리키게 해줄 뿐, 전체를 실선으로 엮는 리스트가 아닙니다.

복잡도 감각

단계별 ++/-- 최악 O(log n) (루트까지 타고 오를 수 있으니).

하지만 전체 순회(begin→end)는 O(n) 이라서 평균(상각)적으로 한 스텝당 O(1) 로 보면 됩니다.

안전·주의 포인트

빈 컨테이너: begin()==end() 이고 --end()는 UB(정의되지 않음). (단, 비어있지 않으면 --end()로 최대 원소 OK)

삭제 무효화 규칙: 지운 원소를 가리키던 이터레이터만 무효. 삽입은 기존 이터레이터 유지.

재균형(회전) 중에도 노드 주소는 유지(재배치 X, 재연결 O) → 이터레이터 안정성의 핵심.

요약 한 줄: 이터레이터는 트리 “그 자체”를 부모/좌/우 포인터로 타고 다니며 중위 순서로 이동한다. 추가 배열/리스트는 없다.

*/

/*

결론부터

헤더(header, 센티넬)는 원소가 아닙니다. size()에 포함되지 않고 값(key/value)도 안 가집니다.

그러나 “원소들이 헤더를 간접적으로 사용”합니다. 트리의 경계·루트·최소/최대를 표시하는 표지판 역할이라, 탐색/순회/삽입·삭제에서 계속 참조됩니다.

비어있지 않을 때(예: 4~5개 넣은 상태)의 연결

header.parent → 루트(root)

header.left → 최소 노드(leftmost) (begin()이 O(1)인 이유)

header.right → 최대 노드(rightmost)

루트의 parent는 헤더를 가리킵니다(상향 이동의 경계).

작게 그리면:

           header(H)
         /     |      \
 leftmost   parent     rightmost
   (min)      |           (max)
              v
             root

“원소에 헤드가 쓰이나?”의 정확한 의미

원소 노드 안에 헤더의 값이 저장되는 건 전혀 없음.

다만 포인터 연쇄의 경계로서 쓰입니다.

증가/감소(iter++)/(--iter):

최대 원소에서 ++ 하면 end()(=헤더) 로 갑니다.

--end() 는 최대 원소를 줍니다(컨테이너가 비어있지 않을 때 표준적으로 허용).

탐색 중 상향 이동: 오른쪽 자식이 없을 때 조상으로 타고 올라가다 **헤더를 만나면 “더 큼/더 작음이 없다”**는 뜻.

삽입·삭제 재균형: 내부 헬퍼들이 헤더를 경계 노드로 넘겨 받아, 빈 트리 처리·최소/최대 갱신을 쉽게 합니다.

자주 받는 오해 정리

헤더의 색/필드는 구현 세부일 뿐, 레드블랙 성질(균형·높이 보장) 은 실제 원소 노드들만으로 성립합니다.

리프(빈 자식) 는 일반적으로 nullptr 이고, 헤더는 리프 대용이 아닙니다. 헤더는 트리 바깥 경계 전용.

요약 한 줄

헤더 = 값 없는 “경계·지표 노드”. 원소는 아니지만, 모든 순회/삽입/삭제가 헤더를 경계로 삼아 동작합니다.

*/

/*

libstdc++ stl_tree.h 레드블랙 트리 — 구현적 특징 요약

아래는 std::map / std::set의 내부 컨테이너인 _Rb_tree 구현을 “구조 → 노드/이터레이터 → 삽입/삭제 → 탐색/병합 → 보장사항” 순서로 핵심만 정리한 것입니다.

1) 큰 그림

이 파일은 map,set을 구현하기 위한 내부 헤더입니다. 삽입/삭제 알고리즘은 CLRS 기반이며, 
헤더 셀(header sentinel) 이 루트뿐 아니라 최소/최대 노드에도 연결되어 begin()을 O(1) 로 제공합니다. 
또한 삭제 시 후계자 노드를 복사하지 않고 ‘재연결(relink)’ 하여 삭제된 노드를 가리키는 반복자만 무효가 되게 합니다.

2) 자료구조 뼈대

공통 베이스 노드: 색, 부모, 좌/우 자식 포인터로 구성되며, 
서브트리 최소/최대 노드를 찾는 정적 헬퍼가 있습니다.

헤더/메타데이터: _Rb_tree_header 가 센티넬 _M_header 와 노드 수 _M_node_count 를 보관합니다. 
생성자에서 센티넬 색을 red 로 두고 _M_reset() 으로 parent=null, left/right=자기자신, count=0 로 초기화합니다.

구현 클래스 레이아웃: 비교자/할당자/헤더를 상속으로 묶은 _Rb_tree_impl 내부에 루트/leftmost/rightmost 접근자가 정의됩니다(캐시된 포인터).

3) 노드와 이터레이터

노드 저장: C++11 이후 값 저장은 __aligned_membuf<_Val> 로 정렬 보장/수명 제어를 합니다(_M_valptr() 로 값 포인터 획득).

이터레이터: 양방향 반복자이며, 증감 연산은 트리 내 중위 순회 다음/이전 노드를 찾는 내부 헬퍼 _Rb_tree_increment/_Rb_tree_decrement에 위임합니다.

4) 삽입(emplace/insert)과 재균형

공개 인터페이스는 emplace/insert/insert_hint/범위 삽입 등으로 구성됩니다(Unique/Equal 두 계열).

실제 링크와 색 재조정은 전용 훅 함수 _Rb_tree_insert_and_rebalance(insert_left, x, parent, header) 가 담당합니다(선언부).

헤더가 leftmost/rightmost 를 캐시하므로 begin() 은 헤더의 왼쪽 링크만 따라가면 되어 상수 시간입니다(설계 설명).

5) 삭제(erase)와 재균형

erase(pos/begin,end) 등은 내부에서 _M_erase_aux → _Rb_tree_rebalance_for_erase(node, header) 로 연결을 풀고, 
노드를 파괴/카운트 감소합니다.

설계상 두 자식을 가진 노드 삭제 시 ‘후계자 재연결’ 방식을 써서, 
삭제된 노드를 가리키던 반복자 외에는 무효화되지 않도록 합니다(설계 주석).

6) 탐색과 범위 질의

find / count / lower_bound / upper_bound / equal_range 를 제공하며,
 내부적으로 키 비교와 서브트리를 따라 내려가는 헬퍼를 사용합니다.

C++14 이후에는 투명 비교자(is_transparent) 최적화 경로도 준비되어 있습니다.

7) C++17 노드 핸들(Node Handle) & 병합

노드 추출/재삽입: extract 로 노드를 꺼내고, _M_reinsert_node_* 로 동일/동등키 컨테이너에 되삽입합니다. 
내부적으로 역시 _Rb_tree_rebalance_for_erase 를 사용하여 추출합니다.

컨테이너 간 병합(merge): 호환 트리에서 하나씩 꺼내 목적지 트리에 삽입합니다(Unique/Equal 각각 경로 제공).

8) 메모리 관리상의 트릭

복사/재구성 과정에서 노드 재활용 풀( _Reuse_or_alloc_node )을 사용해, 가능한 노드를 재사용하고 필요 시에만 할당합니다.

9) 시간 복잡도 & 반복자 안정성(요지)

레드블랙 속성으로 트리 높이가 O(log n) 에 유지되어, 탐색/삽입/삭제 모두 평균·최악 O(log n) 입니다(일반적 RB-트리 성질).

반복자 무효화 규칙: 삽입은 기존 반복자를 유지하는 것이 표준 컨테이너 보장이고, 
삭제는 삭제된 원소를 가리키던 반복자만 무효가 되도록 설계되어 있습니다(후계자 재연결 주석 참조).

*/