  /**
   *  @brief A standard container composed of unique keys (containing
   *  at most one of each key value) that associates values of another type
   *  with the keys.
   *
   *  @ingroup unordered_associative_containers
   *  @headerfile unordered_map
   *  @since C++11
   *
   *  @tparam  _Key    Type of key objects.
   *  @tparam  _Tp     Type of mapped objects.
   *  @tparam  _Hash   Hashing function object type, defaults to hash<_Value>.
   *  @tparam  _Pred   Predicate function object type, defaults
   *                   to equal_to<_Value>.
   *  @tparam  _Alloc  Allocator type, defaults to 
   *                   std::allocator<std::pair<const _Key, _Tp>>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, and
   *  <a href="tables.html#xx">unordered associative container</a>
   *
   * The resulting value type of the container is std::pair<const _Key, _Tp>.
   *
   *  Base is _Hashtable, dispatched at compile time via template
   *  alias __umap_hashtable.
   */

  template<typename _Key, typename _Tp,
	   typename _Hash = hash<_Key>,
	   typename _Pred = equal_to<_Key>,
	   typename _Alloc = allocator<std::pair<const _Key, _Tp>>>
    class unordered_map
    {
      typedef __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc>  _Hashtable;
      _Hashtable _M_h;
    }


/*

조회/접근

at(key)
무엇: 존재 확인 + 참조 반환, 없으면 std::out_of_range 예외.
⇒ 평균 O(1) / 최악 O(N)
포인트: 예외로 실패 신호. 읽기·쓰기 모두 가능(비-const에서).

operator[](key)
무엇: 없으면 **디폴트 생성값(여기선 0)**으로 삽입 후 참조 반환.
⇒ 평균 O(1) / 최악 O(N) (삽입 포함)
포인트: 맵이 변할 수 있음. 존재 체크만 하고 싶을 땐 find/contains(C++20)가 낫다.

find(key)
무엇: 있으면 iterator, 없으면 end().
⇒ 평균 O(1) / 최악 O(N)

count(key)
무엇: 존재 개수 반환(보통 0 또는 1).
⇒ 평균 O(1) / 최악 O(N)

equal_range(key)
무엇: 그 키의 구간 [first,last) 반환(유니크 맵에선 “있으면 그 하나, 없으면 빈 구간”).
⇒ 평균 O(1) / 최악 O(N)

반복자

begin() / end() / cbegin() / cend()
무엇: 전역 단일 리스트 순회용 시작/끝 반복자.
⇒ O(1)
포인트: 순서 보장 없음. rehash/reserve 시 반복자 전부 무효화.

버킷 관찰/튜닝

bucket(key)
무엇: 해당 키가 들어갈(혹은 들어있는) 버킷 인덱스.
⇒ 평균 O(1) / 최악 O(N) (탐색 포함)

bucket_count()
무엇: 현재 버킷 개수(테이블 크기).
⇒ O(1)

bucket_size(i)
무엇: i번 버킷에 들어있는 원소 수(충돌 정도).
⇒ O(1) (libstdc++는 헤드에 길이를 들고 있어 상수)

load_factor()
무엇: size()/bucket_count() (실제 로드팩터).
⇒ O(1)

max_load_factor() / max_load_factor(float f)
무엇: 평균 체인 길이 목표(기본 ≈1.0) 조회/설정.
⇒ O(1)
포인트: 낮추면 충돌↓/메모리↑. 임계 초과 시 삽입이 rehash 유발.

max_bucket_count()
무엇: 구현이 허용하는 버킷 최대치.
⇒ O(1)

rehash(n)
무엇: 버킷 수를 최소 n 이상으로 재조정(재배치).
⇒ O(N)
포인트: 모든 반복자 무효화, (표준상) 참조/포인터는 유지. 성능 튜닝용.

reserve(n)
무엇: n개 원소를 재해시 없이 담을 수 있도록 버킷 확대.
⇒ O(N)(필요 시 재해시)
포인트: 대량 삽입 전 호출하면 좋다.

삽입/갱신

emplace(args...)
무엇: 자리에서 직접 생성 삽입(복사/이동 최소화).
⇒ 평균 O(1) / 최악 O(N)
반환: pair<iterator,bool> (성공 여부 포함). 키 중복이면 삽입 안 함.

emplace_hint(pos, args...)
무엇: 힌트 버전(순서가 없는 컨테이너라 힌트 무시에 가깝다).
⇒ 평균 O(1) / 최악 O(N)
반환: iterator

insert(value) / insert(range/il)
무엇: 값 삽입(중복키면 무시).
⇒ 평균 O(1) / 최악 O(N) (배열/범위는 합산)

insert_or_assign(key, value)
무엇: 없으면 삽입, 있으면 값만 대입.
⇒ 평균 O(1) / 최악 O(N)
반환: pair<iterator,bool>(삽입했는지 여부)

try_emplace(key, ctor-args...)
무엇: 없을 때만 그 자리에서 값 생성(있으면 생성 자체 안 함).
⇒ 평균 O(1) / 최악 O(N)
포인트: 기존 값이 있을 때 불필요한 임시 생성 없음.

삭제/추출/병합

erase(key)
무엇: 그 키(있다면 1개) 삭제, 반환값은 삭제 개수(0/1).
⇒ 평균 O(1) / 최악 O(N)

erase(it) / erase(first,last)
무엇: 이터레이터/구간 삭제.
⇒ 평균 O(1) / 구간은 O(거리)

extract(key) / extract(it)
무엇: 노드 핸들로 꺼냄(컨테이너 밖에서 key 수정/이식 가능).
⇒ 평균 O(1) / 최악 O(N)
포인트: node_type은 키/값/할당자 정보 포함. insert(std::move(node))로 다른 컨테이너에 이동 가능.

merge(other)
무엇: other에서 중복되지 않는 키 노드를 이 컨테이너로 이동.
⇒ 평균 O(k) (이동된 노드 수) / 최악 O(N)
포인트: 값 복사 대신 노드 이동이라 싸다. 중복 키는 other에 남음.

컨테이너 상태/메타

size() / empty() / clear()
무엇: 크기/비었는지/모두 제거(버킷은 보통 유지).
⇒ size/empty O(1) / clear는 O(N)

swap(other)
무엇: 내용/버킷 교환.
⇒ 보통 O(1) (포인터 스왑 수준)
포인트: 반복자·포인터 유효성은 컨테이너에 귀속되므로 주의.

max_size()
무엇: 이론상 담을 수 있는 최대 원소 수.
⇒ O(1)

operator=(...)
무엇: 복사/이동/초기화 리스트 대입.
⇒ 복사 O(N), 이동 보통 O(1), ilist는 O(n)

get_allocator()
무엇: 사용 중인 할당자 반환.
⇒ O(1)

hash_function() / key_eq()
무엇: 현재 해시 함수자 / 동치 비교자 반환(복사).
⇒ O(1)

구현적 특징(요약 메모)

체이닝(separate chaining) + **버킷 엔트리는 해당 체인의 ‘직전 노드’**를 가리키는 구조 → 삽입/삭제가 insert_after/erase_after로 평균 O(1).

reserve/rehash로 **버킷 수(B)**를 제어해 로드팩터를 관리하면 충돌을 낮출 수 있다.

반복자 무효화: rehash/reserve 시 전부 무효. erase(it)는 그 이터레이터만 무효.

참조/포인터: 표준 구현 대부분에서 rehash 후에도 유효(노드 재할당 없이 재배치)지만, 반복자 규칙에 의존하는 게 안전하다.

*/


  /*
  
  메모리 구조 & 충돌 처리

버킷 배열 + 전역 단일 연결 리스트 이중 구조. 모든 원소는 하나의 전역 단일 리스트로 이어지고, 
**버킷 엔트리는 “그 버킷 첫 노드의 직전 노드(before-node)”**를 가리킴. 그래서 삽입/삭제를 insert_after/erase_after로 O(1) 평균 비용에 처리.

충돌(separate chaining): 같은 버킷의 노드가 단일 리스트로 연결.
unique 계열(unordered_map/set): 새 원소는 보통 그 버킷 체인의 앞에 붙음(중복 키 검사 후).
multi 계열: 동일 키 구간의 뒤에 붙여 같은 키의 상대 순서를 유지하도록 처리.

iterator & 순회

일반 iterator는 전역 리스트를 따라가므로 ++비용이 일정.
local_iterator로 특정 버킷 구간만 순회 가능.
순서 보장 없음(rehash/삽입으로 쉽게 바뀜). 반복자 무효화 규칙: rehash/reserve 시 반복자 전부 무효화(단, 노드 참조/포인터는 보통 유지).

시간 복잡도(감각)

평균적으로 find/insert/erase O(1), 최악 O(N)(한 버킷에 몰릴 때).
rehash는 O(N) 재배치. 대량 삽입 전 reserve(n)으로 줄이는 게 핵심.

버킷 수·로드 팩터 정책

버킷 수 B는 동적이며 대략 ceil(size / max_load_factor) 쪽으로 유지.
기본 max_load_factor() ≈ 1.0. max_load_factor(0.7~0.8)로 낮추면 충돌↓/메모리↑.
reserve(n)은 내부적으로 그 n개를 재해시 없이 담을 만큼 버킷을 늘림.
libstdc++은 mod range hashing + prime rehash policy를 쓴다(버킷 수를 적절한 수열로 올림).

해시/동치/이종 조회

템플릿 인자: <Key, T, Hash, KeyEqual, Alloc>(set류는 T 없음).
조건: KeyEqual(a,b)==true면 **반드시 Hash(a)==Hash(b)**가 되게 설계.
C++20 이후 투명(heterogeneous) lookup을 지원하는 구현 경로가 있어 find/equal_range를 string_view 등으로 바로 칠 수 있음(투명 해시/동치 정의 시).

삽입 API와 중복 처리

emplace/insert/try_emplace/insert_or_assign 등 지원.
unique 계열: 키 존재 시 삽입 실패(or assign), 중복 검사 때문에 해당 버킷 체인만 선형 스캔.
multi 계열: 항상 삽입, 같은 키 구간의 끝을 찾아 붙임(그 키 개수만큼만 스캔).
C++17 node handle extract/insert(node), merge로 컨테이너 간 노드 이동이 싸고 깔끔.

삭제/정리

erase(it), erase(key), erase(first,last) 제공.
key 기반 삭제는 해당 버킷 체인만 훑어 지움(멀티는 여러 개).
clear()는 모든 노드 파괴, 버킷 배열은 보통 유지.

버킷 인터페이스(디버깅/튜닝에 유용)

bucket_count() / bucket(key) / bucket_size(i)로 충돌 상태를 직접 관찰.
load_factor() / max_load_factor() / rehash(n) / reserve(n)로 충돌률·메모리를 트레이드오프 조절.

참조/포인터 안정성(노드 기반의 장점)

노드 기반이라 rehash 전 삽입/삭제만으로는 대체로 참조/포인터가 유지(반복자는 상황에 따라 무효).
rehash는 반복자 전부 무효. 포인터/참조는 구현상 보통 유효(노드 재할당 않음)하지만 표준 보장은 반복자 중심으로 생각하는 게 안전.

알로케이터/PMR

Allocator로 노드 풀을 쓰면 삽입/삭제가 많은 워크로드에서 이득.
PMR(std::pmr::unordered_*)로 런타임에 메모리 리소스 교체 가능.

실전 체크리스트

예상 개수 알면 reserve(n) 먼저 → rehash 줄이기.
충돌 많다 싶으면 max_load_factor(0.7~0.8) 조절.
hot path면 해시 함수 품질 점검(동치 → 같은 해시), 키가 작고 단순하면 해시 캐시 옵션(구현) 고려.
순서 의존 금지(특히 multi/rehash). 순서가 필요하면 별도 구조 사용.
노드 많은 컨테이너(multi, frequent insert/erase)에 풀/PMR 적용 검토.

참고: libstdc++의 unordered_map/unordered_multimap 헤더는 내부 _Hashtable로 위 특성을 구현하며, 
버킷·로드팩터·삽입/삭제·찾기·버킷 인터페이스와 정책 함수들이 모두 노출돼 있다.
  
  */